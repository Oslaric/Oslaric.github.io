/*! For license information please see main.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./src/allApplication.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./src/helpers.js");\n/* harmony import */ var _lib_rangy_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/rangy-core.js */ "./src/lib/rangy-core.js");\n/* harmony import */ var _lib_rangy_classapplier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/rangy-classapplier.js */ "./src/lib/rangy-classapplier.js");\n/* harmony import */ var _lib_rangy_highlighter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/rangy-highlighter.js */ "./src/lib/rangy-highlighter.js");\n/* harmony import */ var _debug_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./debug.js */ "./src/debug.js");\n/* harmony import */ var _debug_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_debug_js__WEBPACK_IMPORTED_MODULE_4__);\n\n/*\n    存放基本的 js , 包括对外的 API 的基本常用的函数\n */\n\n\n/*\n    input 提供给外部的接口进行调用 ---------------------------------------------------------------------------------------\n */\n// require(\'./initial.js\')\n\n\n\n\n\n\n// require(\'./lib/rangy-core.js\');\n// require(\'./lib/rangy-classapplier.js\');\n// require(\'./lib/rangy-highlighter.js\');\n\nlogger.debug("going to load basic.js ")\n\n/**\n * 滚动到 对应的 view 的时候 ,传递具体的值 .\n * 当传递的值为 null 的时候, 说明 focus 在另一个 view \n * @param {double} x \n * @param {double } y 允许 y == null , 当 y 等于 y 的时候 ,当前的 document 已经不是 focus document 了 \n */\nreaderInput.onScroll = function (x, y) {\n    this.delegateImpl.onScroll(x, y)\n}\n\n/**\n * 返回阅读的位置 \n * @param {*} y \n */\nreaderInput.reportReadingProgress = function(y){\n    this.delegateImpl.reportReadingProgress(y)\n}\n/**\n * 返回阅读的进度 \n * @param {scrollY} 浏览器底部的 y 坐标 \n */\nreaderInput.reportTrueReadingProgressInfo = function(scrollY){\n    this.delegateImpl.reportTrueReadingProgressInfo(scrollY)\n}\n\n/**\n * 打标记 \n */\nreaderInput.mark = function(markId, markClass)  {\n    this.delegateImpl.mark(markId, markClass)\n}\n\n/**\n * 添加 note \n */\nreaderInput.addNote = function(markId, markClass)  {\n    var res = this.delegateImpl.addNote(markId, markClass)\n    // 这个方法特殊一点 , 有返回值  \n    return JSON.stringify(res)\n}\n\n/**\n * 将当前的 mark 标记为 有 note \n */\nreaderInput.markNote = function(hasNote)  {\n    this.delegateImpl.markNote(hasNote)\n}\n\n/**\n * 加载 用户创建的  marks \n */\nreaderInput.loadMarks = function(marks) {\n    this.delegateImpl.loadMarks(marks)\n}\n\n/**\n * 删除 mark (last mark )\n * 用户点击的 mark 的时候 ,我们会将用户最近与之交互的 mark 记录在 js 的 context  里面  , 这样删除的时候就不用传递 markId 了 \n */\nreaderInput.deleteMark = function() {\n    this.delegateImpl.deleteMark()\n}\n/**\n * 跳转到那个 anchor(element )\n */\nreaderInput.gotoAnchor = function(anchorValue)  {\n    this.delegateImpl.gotoAnchor(anchorValue)\n}\n\n/**\n * 导入 anchor 列表 ,一般都是 toc 目录 需要跳转的 anchor\n */\nreaderInput.loadAnchorsResponse = function(anchors) {\n    this.delegateImpl.loadAnchorsResponse(anchors)\n}\n\n/**\n * 改变 字体的大小\n */\nreaderInput.changeFontSize = function(fontSize) {\n    // 和初始化的 setFontSize 存在差别 \n    this.delegateImpl.changeFontSize(fontSize)\n}\n\n/**\n * 解冻 当前阅读位置对应的 range  \n * 也就是说 : 我们有些时候会把当前位置(scrollY) 对应的 range 保存起来 \n */\nreaderInput.unfreezeReadingRange = function()  {\n    this.delegateImpl.unfreezeReadingRange()\n}\n\n/**\n * 改变 mode , 或者说是改变主题 \n * 现在不用,后面提供更加丰富的主题时用到\n */\nreaderInput.changeMode = function(isDark){\n    this.delegateImpl.changeMode(isDark)\n}\n/**\n * 屏幕旋转前的 hook\n */\nreaderInput.handleScreenRotationBefore = function(scrollY)  {\n    this.delegateImpl.handleScreenRotationBefore(scrollY)\n}\n/**\n * 屏幕旋转后的 hook\n */\nreaderInput.handleScreenRotationAfter = function(scrollY) {\n    this.delegateImpl.handleScreenRotationAfter(scrollY)\n}\n/**\n * 获取翻译用的 text\n */\nreaderInput.requestTranslateTexts = function() {\n    this.delegateImpl.requestTranslateTexts()\n}\n\n\n/*\n output 输出到外部\n */\n\nvar readerOutput = {\n    onDocumentReady: function () {\n        readerMessager.sendSuccessMessage("onDocumentReady", null)\n    }\n    , onDocSizeChanges: function (docSize, x, y) {\n        // y 在没有值的时候 为 null\n        var result = {\n            "docSize": docSize,\n            "scrollY": y\n        }\n        readerMessager.sendSuccessMessage("onDocSizeChanges", result)\n    }\n    , onSaveProgress: function (compositLocator) {\n        readerMessager.sendSuccessMessage("onSaveProgress", compositLocator)\n    }\n    , onReportTrueReadingProgressInfo: function (percent) {\n        readerMessager.sendSuccessMessage("onReportTrueReadingProgressInfo", percent)\n    }\n\n\n    , onNewSelectionExist: function (rect, selectedRenderText, sentence) {\n        // 只要 selection 一直存在 ,用户一直在和这个 selection 交互(比如 touch 的 轨迹落到 之前存在的 selection 上面) ,这个方法就会被调用\n        var result = { rect, selectedRenderText, sentence }\n\n        readerMessager.sendSuccessMessage("onNewSelectionExist", result)\n    }\n    , onClickNonSelectionArea: function (point) {\n        readerMessager.sendSuccessMessage("onClickNonSelectionArea", point)\n    }\n\n    , onClickMark: function (markId, rect, selectedText, sentence, hasNote) {\n        var result = {\n            markId,\n            rect,\n            selectedText,\n            sentence,\n            hasNote,\n        }\n        readerMessager.sendSuccessMessage("onClickMark", result)\n    }\n\n    , onMarkCreated(markId, markClass, removeMarkIds, percentRate, location, text, isNoting) {\n        // isNoting 和 hasNote 是有区别的  , isNoting == true 是声明 这个操作是 addNote 操作 \n        var result = { markId, markClass, removeMarkIds, percentRate, location, text, isNoting }\n        readerMessager.sendSuccessMessage("onMarkCreated", result)\n    }\n\n    , onMarkClassChange(markId, markClass) {\n        // 用于通知 app 哪个 mark 的 style 修改了 \n        readerMessager.sendSuccessMessage("onMarkClassChange", { markId, markClass })\n    }\n    // ,onNoteCreated(markId , markClass, removeMarkIds , percentRate , location  , text ) {\n    //     // 不和  onMarkCreated 进行合并的原因 : mark 的 hasNote 不一定说明是 addNote 操作 , 也可能是合并的其他 mark 带有 note  \n    //     var hasNote = true \n    //     var result = { markId , markClass , removeMarkIds , percentRate , location , text  , hasNote }\n    //     readerMessager.sendSuccessMessage("onNoteCreated", result)\n    // }\n\n    , requestToLoadMarks(percentRate, pageSize) {\n        readerMessager.sendSuccessMessage("requestToLoadMarks", { percentRate, pageSize })\n    }\n    , loadAnchorsRequest() {\n        readerMessager.sendSuccessMessage("loadAnchorsRequest", 0) // 0 没有意义\n    }\n\n    , onAnchorReachRequest(anchorValue) {\n        readerMessager.sendSuccessMessage("onAnchorReachRequest", anchorValue)\n    }\n\n    , onClickImage(link) {\n        readerMessager.sendSuccessMessage("onClickImage", link)\n    }\n\n    , responseTranslateTexts(word ,sentence , paragraph){\n        readerMessager.sendSuccessMessage("onTranslateTexts", {word ,sentence , paragraph})\n    }\n}\n\n\n\n/*\n *  开始具体的实现 ----------------------------------------------------------------------------------------\n */\nvar ELEMENT_NODE_TYPE = 1\nvar TEXT_NODE_TYPE = 3\nvar FILTER_NODE_TYPES = [Node.ELEMENT_NODE, Node.TEXT_NODE, Node.DOCUMENT_FRAGMENT_NODE]\n\nfeelwithme.init // 记录初始化的信息\nfeelwithme.readingLocate = {\n    range: null, // 用于固定住阅读位置 , 固定阅读位置 ,以方便后面做 字体 行距 , padding 等的调整 \n    scrollY: null, // 这个用记录用户实时的浏览偏移量 , 和 range 字段不同在于 , range 是用来固定阅读位置的 \n    reportScrollY: null // 用于记录上次汇报的 偏移量 y\n}\nfeelwithme.viewInfo = { // 用于记录当前这个 view 的信息 , 比如 documentSize\n    "docHeight": 0, // 上次向 native 汇报的 document 的高度 \n    "scrollY": null   // 上次向 native 汇报的 偏移量 \n}\n// 保存是为了避免用户或者脚本中途修改了\nfeelwithme.bodyVisibleText = null\nfeelwithme.tailMark = null // 最尾部的 bookmark \nfeelwithme.readerView = {} // 记录 ReaderView 的 viewport 信息\nfeelwithme.loadMark = {}; feelwithme.loadMark.pageSize = 50; feelwithme.loadMark.done = false; // 记录 ReaderView 的 viewport 信息\nfeelwithme.resizeObserver  // 记录 documentSize 变化 \nfeelwithme.anchor = {}\nfeelwithme.anchor.list = [] // 记录每个 document 的 anchor 列表\nfeelwithme.anchor.lastIndex = 0 // 记录上次显示 anchor 的位置 \nfeelwithme.anchor.lastValue = null // 记录上次显示 anchor 的位置 \nfeelwithme.viewPort = {}  // 用于记录整个 阅读 rectangle 的大小 , 在当前是实现中 ,指的是 scrollView 的大小 \nfeelwithme.markClassList = ["mark-A", "mark-B", "mark-C", "mark-D", "mark-E"]  // 记录标记列表 \nfeelwithme.screenRotation = {} // 用于记录 screenRotation 的信息\nfeelwithme.operationLocation = {}\nfeelwithme.operationLocation.text = {}\n/**\n * 抄自 : https://stackoverflow.com/questions/641857/javascript-window-resize-event   frontsideup 的 answer \n * @param {*} func\n * @param {*} delay  in milliseconds\n * @param {*} immediate   immediate = true 就是总是 取 interval 里面的 第 1 个  ,否则取最后一个\n * @returns\n */\nfunction debounce(func, delay = 200, immediate = true) {\n    let timeout;\n    return function () {\n        const context = this,\n            args = arguments;\n        const later = function () {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, delay);\n        if (callNow) func.apply(context, args);\n    };\n}\n\n/**\nfrom : https://stackoverflow.com/questions/27078285/simple-throttle-in-javascript   \n * Returns a function, that, when invoked, will only be triggered at most once\n    during a given window of time. Normally, the throttled function will run\n    as much as it can, without ever going more than once per `wait` duration;\n    but if you\'d like to disable the execution on the leading edge, pass\n    `{leading: false}`. To disable execution on the trailing edge, ditto.\n * @param {*} func \n * @param {function} waitSupplier \n * @param {*} options \n * @returns \n */\nfunction throttle(func, waitSupplier, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n    };\n    return function () {\n        var now = Date.now();\n        var wait = waitSupplier()\n        if (!previous && options.leading === false) previous = now;\n        var remaining = wait - (now - previous); //---\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) { //--\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n        return result;\n    };\n};\n\nfunction isSameTagName(a, b) {\n    if (a == null || b == null) {\n        return false\n    }\n    return a.toLowerCase() == b.toLowerCase()\n}\n\nfunction tryToGetDocHeight() {\n    /*\n        获取页面的高度(不一定是 content的高度 ,放大字体以后会导致 frame 变大 ,变大以后就无法缩回来了  )\n        获取页面的高度 , 这个方法获取的高度并不一定准确 , 有一个 case 是这样的 :\n            WKWebview 的 frame 设置得非常大以后 ,哪怕后来把字体等调小,导致整个 document 的 size 变小 了,这个方法还是返回 frame 的高度\n    */\n    const body = document.body;\n    const html = document.documentElement;\n    return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n}\n\nfunction getDocWidth() {\n    const body = document.body;\n    const html = document.documentElement;\n    return Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);\n}\n\nfunction getBodyBottomHeight(includeMargin = true) {\n    let body = document.body\n    if (body.children.length == 0) {\n        return 0\n    }\n    var lastElementBottomY = body.lastElementChild.getBoundingClientRect().bottom\n    var margin = Math.abs(body.scrollHeight - body.offsetHeight);\n    return lastElementBottomY + (includeMargin ? margin : 0)\n}\n\nfunction getDocHeight() {\n    /*\n        为什么会有这个方法 ?\n        因为 : 用户在增大字体以后再缩小时 , tryToGetDocHeight() 还是会返回以前变大时的大小 ,而不是自动适配.\n            我猜测的原因: 因为我之前是通过 js 告诉 WKWebView doc 的大小 ,然后调整 WKWebView 的大小 .\n                但是因为 WKWebView 在字体变大了以后 , WKWebView 的 frame 已经变大 , 这时候 tryToGetDocHeight 就会返回这个窗口的大小,而不是返回 文本内容所占据的大小\n    */\n    let a = tryToGetDocHeight()\n    let body = document.body\n    // Math.abs(body.scrollHeight - body.offsetHeight)  这一段我暂时也不知道有没有必要,感觉像是 border 一样的东西,加上去也无妨\n    if (body.lastElementChild == null) {// has no child in body , 这种情况是存在的 ,见过  .\n        return a;\n    }\n    let b = getBodyBottomHeight()\n    // 超过  threshold dp 说明 content 的高度 和 tryToGetDocHeight 函数返回的值 存在 巨大的偏差 , 所以 以 a 的结果为准 , threshold 是一个经验值\n    let threshold = 100\n    var result = 0\n    if ((a - b) > threshold) {\n        result = b;\n    } else {\n        result = a;\n    }\n    logger.trace("getDocHeight : " + result)\n\n    return result\n}\n\n/**\n * 文档加载完毕以后 ,汇报 document size 和上次阅读的位置\n */\nfunction reportInitialSizeAndPosition() {\n    const readingLocation = feelwithme.init.readingLocation\n    var docHeight = getDocHeight();\n\n    if (readingLocation == null) {\n        // 没有定位信息 ,说明当前文档不是 focus \n        logger.debug("reportInitialSizeAndPosition: start from head")\n        reportInitialLocationInfo(docHeight, null)\n        return\n    }\n    /*\n        基于 {菜单,链接 } 的定位 \n    */\n    var y = 0\n    if (readingLocation.locationType == 1) {\n        if (readingLocation.anchorValue.trim().length == 0) {\n            reportInitialLocationInfo(docHeight, y)\n        } else {\n            y = getPositionYOfAnchor(readingLocation.anchorValue)\n            reportInitialLocationInfo(docHeight, y)\n        }\n        logger.debug("reportInitialSizeAndPosition: start from toc , y : ", y)\n        return\n    }\n\n    var location = readingLocation.location\n    if (location == null) {\n        //  locationType == 0 的情况下  , location 还是可能 为 null 的 ,比如 没有初始化 \n        reportInitialLocationInfo(docHeight, null)\n        return\n    }\n\n    // 如果 存在偏移量 ,直接获取偏移量 , 修正 : 不能够直接基于偏移量 ,因为 : ipad 和 iPhone ,同一个 {document ,偏移量 } 由于 宽度不同,导致显示的内容不同 \n    // if (location.documentOffset != null) {\n    //     reportInitialLocationInfo(docHeight, location.documentOffset)\n    //     return\n    // }\n\n    // 如果 没有偏移量 ,只好基于 xpath 或者 文本进行定位了         \n    var range = findRangeForLocation(location)\n    if (range != null) {\n        y = range.getBoundingClientRect().y\n        /*\n            疑惑 : 为什么 range.getBoundingClientRect().y 总是返回上一行的 top 的 y 坐标 ?\n            比如 \n            ABCD\n            EFGH\n            中 ,如果 range 选中了 E 这个 word , 那么 在有些时候(应该不是总是如此) , range.getBoundingClientRect().y 返回的是 A 的 top 的 y 坐标 \n            所以,为了保险起见 : 以后可以考虑不取对应行的第一个 字符 ,而是取第二个 字符 ,第二个字符就可以保证很准确了 .当然, 前提是存在 第二个字符 .\n        */\n        logger.debug("range content : ", range.toString(), "scroll Y : ", y)\n    } else {\n        y = null  // todo : 支持 基于 文本的定位\n    }\n    // todo : 后期基于 text 进行定位 \n    logger.debug("reportInitialSizeAndPosition: start from mark , y : ", y)\n    reportInitialLocationInfo(docHeight, y)\n\n    logger.debug("end reportInitialSizeAndPosition ")\n}\n\n/**\n * 报告 document 的高度 和 初始化的阅读位置 \n * @param {*} docHeight \n * @param {*} readingPositionY  readingPositionY == 0 和 readingPositionY == null 是有区别的 \n */\nfunction reportInitialLocationInfo(docHeight, readingPositionY) {\n    readerOutput.onDocSizeChanges(docHeight, 0, readingPositionY)\n    /* \n        移除掉执行 onScroll 方法 的原因是 : readingViewController 才是 onScroll 方法唯一的 truth 权威源头 . 当 readerOutput.onDocSizeChanges 执行以后 , readingViewController 会通知 js 真实 的 scrollY ,而不是js 自行执行自己的方法\n        todo : 考虑一个问题: 如果移除执行 onScroll 方法, 这时候 如果 whenDocSizeChanges 在 scrollY 没有被赋值 时再次被触发了 怎么办 ? 这这时候会不会永久性的丢失 scrollY 信息 ? \n            我不确定, 可以考虑 : 设置 scrollY \n        \n\n        发现一个问题 : 为什么在不移动的情况下 , js 没有接收到 onScroll 的 回调 ???  \n    */\n    if (readingPositionY != null) {\n        //     // todo 下面这个改成异步(timeout )\n        //     readerInput.onScroll(0, readingPositionY)\n        resetCurrentReadingScrollY(readingPositionY)\n    }\n}\n\nfunction getPositionYOfAnchor(anchorName) {\n    if (anchorName == "") {\n        return 0 // anchorName == "" 说明对应整个文档 ,这时候 直接返回 0 \n    }\n    var ele = document.getElementById(anchorName)\n    if (!ele) {\n        ele = document.getElementsByName(anchorName)[0]\n    }\n    if (ele) {\n        return ele.getBoundingClientRect().y\n    } else {\n        return null\n    }\n}\n\n\nfunction getBoundingClientRectsAnchors(anchorNames) {\n    var res = []\n    for (var i = 0; i < anchorNames.length; i++) {\n        var anchorName = anchorNames[i]\n        var ele = document.getElementById(anchorName)\n        if (!ele) {\n            ele = document.getElementsByName(anchorName)[0]\n        }\n        var rect = null\n        if (ele) {\n            rect = ele.getBoundingClientRect();\n        }\n        res.push(rect)\n    }\n    return res\n}\n\nfunction findRangeForLocation(aLocation) {// 完了 ,这下子 basic 依赖 rangy 框架了 ...唉 \n    logger.debug("findRangeForLocation , location  : ", JSON.stringify(aLocation))\n    let rangyRange = findRangyRangeForBookmark(aLocation.xpathLocation)\n    if (rangyRange == null) {\n        return null\n    }\n    return rangyRange.nativeRange\n}\n\nfunction findRangyRangeForLocation(aLocation) {\n    return findRangyRangeForBookmark(aLocation.xpathLocation)\n}\n\n\nfunction findRangyRangeForBookmark(bookmark) {\n    // logger.debug("findRangyRangeForBookmark , mark : " , JSON.stringify(bookmark) )\n    // 用到了 rangy\n    var rangyRange = _lib_rangy_core_js__WEBPACK_IMPORTED_MODULE_1__.rangy.createRange()\n    var containerNode = findNodeByXpath(bookmark.containerXPath)\n    if (containerNode == null) {\n        logger.error("failed to find path : ", bookmark.containerXPath)\n        return null\n    }\n    /*\n        fix: 当 container 是 block 的时候 , 并且选择的就是 自身 ,那么 bookmark.start == bookmark.end\n        也许你会问 : 为什么 不选 container 的 parent 作为 参考 base 呢?  因为有可能是 body , 而如果是 body 的话 , start 就是基于 字符串了 ,我不太确定 rangy 可以很好的定位 \n        希望后面有 统一的完美方案 ,不需要这样折腾 ~ \n\n        range 和 rangyRange 的 bookmark 之间并不总是可以等效替换的 , 特别是 range 的范围是 一个 block 类型的 node 时 .\n    */\n    if (bookmark.start == bookmark.end && bookmark.start == 0) {\n        // 意味着选择的是自己\n        var range = document.createRange()\n        range.selectNode(containerNode)\n        rangyRange.setStartAndEnd(range.startContainer, range.startOffset, range.endContainer, range.endOffset)\n        return rangyRange\n    }\n\n    rangyRange.moveToBookmark({\n        start: bookmark.start,\n        end: bookmark.end,\n        containerNode: containerNode\n    });\n    return rangyRange\n}\n\n/**\n * 只做简单解析,只支持 :\n *  - 路径\n *  - 位置([x])\n *  - id\n * case :  { /div[1]/span[2]   ,  //div[@id="xxx"] }\n * 这些组合,其他的概不支持\n *\n * @param {*} xpath\n * @returns\n */\nfunction findNodeByXpath(xpath) {\n    var paths = xpath.split("//")\n    if (paths.length > 1) {\n        xpath = paths[1]\n    } else {\n        xpath = paths[0]\n    }\n    paths = xpath.split("/")\n    var parentNode = document.body\n    var idPrefix = "[@id="\n    for (var i = 0; i < paths.length; i++) {\n        var nodePath = paths[i]\n        if (nodePath.length == 0) {\n            // js 的 split 导致的\n            continue\n        }\n        var idIndex = nodePath.indexOf(idPrefix)\n        if (idIndex != -1) {\n            idIndex += idPrefix.length + 1 // 双引号\n            var idEndIndex = nodePath.indexOf("]", idIndex) - 1 //后面的双引号\n            var id = nodePath.slice(idIndex, idEndIndex)\n            parentNode = document.querySelector("#" + id)\n        } else {\n            var tagName = nodePath.slice(0, nodePath.indexOf("["))\n            var index = parseInt(nodePath.slice(tagName.length + 1, nodePath.length - 1))\n            parentNode = getSameTypeNodeByIndex(parentNode, index, tagName)\n        }\n    }\n    return parentNode\n}\n\n\nfunction shouldReportDocSizeChange(entries, elements, oldDocHeight, newDocHeight) {\n    if (oldDocHeight == null) {//第一次初始化 \n        return true\n    }\n    var bottom = getBodyBottomHeight(false)\n    if (newDocHeight > oldDocHeight && oldDocHeight >= bottom) {\n        return false  // 如果原来的 doc height 已经超过了 最后一个 element 的 bottom , 就没有必要增加高度 了\n    }\n\n    /*\n        为什么这样子写 ?\n            因为如果是真的变小了 , 那么 entries 应该会反馈 2 个 element 都变小(比如调小字体的时候) . 如果只反馈一个(body) , 那么非常有可能是 \n            margin-bottom : -1.0 em 这样的 css + Safari 浏览器 造成的\n    */\n    if (newDocHeight < oldDocHeight && entries.length < 2 && entries[0].target == document.body) {\n        return false\n    }\n\n    return true\n}\nfunction whenDocSizeChanges(entries, elements) {\n    logger.debug("whenDocSizeChanges begin ")\n    logger.debug("feelwithme.init" + JSON.stringify(feelwithme.init))\n    if (feelwithme.init.state == 0) {\n        feelwithme.init.state = 1\n        logger.debug("whenDocSizeChanges - initReadingPositionIfNeed ")\n        reportInitialSizeAndPosition()\n        return\n    }\n\n    var docHeight = getDocHeight();\n\n    if (!shouldReportDocSizeChange(entries, elements, feelwithme.viewInfo.docHeight, docHeight)) {\n        return\n    }\n\n    // logger.debug("whenDocSizeChanges 000001 ")\n    /*\n        feelwithme.readingLocate.range 存在 ,说明阅读位置被固定\n        如果 feelwithme.readingLocate.range 不存在 ,则使用  getCurrentReadingScrollY 作为当前阅读位置  \n    */\n    var range = feelwithme.readingLocate.range\n    var readingPositionY = null\n    if (range != null) {\n        readingPositionY = range.getBoundingClientRect().y\n        logger.debug("readingPositionY from range : ", readingPositionY)\n    } else {\n        readingPositionY = getCurrentReadingScrollY()\n        logger.debug("readingPositionY from record : ", readingPositionY)\n    }\n\n\n    // logger.debug("whenDocSizeChanges 000002 ")\n    if (feelwithme.viewInfo.docHeight == docHeight && feelwithme.readingLocate.reportScrollY == readingPositionY) {\n        logger.debug("whenDocSizeChanges nothing , skip")\n        return\n    }\n    // 更新 {视图大小 , 汇报的 位置 }\n    feelwithme.viewInfo.docHeight = docHeight\n    feelwithme.readingLocate.reportScrollY = readingPositionY\n\n    resetCurrentReadingScrollY(readingPositionY)\n    // feelwithme.viewInfo.scrollY = readingPositionY\n    // if (!!range) {\n    //     logger.debug("whenDocSizeChanges  , height : ", docHeight, "  y : ", readingPositionY , "range-startContainer : " , getSimpleXpath(range.startContainer) , " ,range : ", range.toString())\n    // } else {\n    //     logger.debug("whenDocSizeChanges  , height : ", docHeight, "  y : ", readingPositionY)\n    // }\n    logger.debug("whenDocSizeChanges 000003 ")\n    readerOutput.onDocSizeChanges(docHeight, 0, readingPositionY)\n    // }\n}\n\n\nfunction whenDocumentTreeHasParsed(callback) {\n    // refer : https://stackoverflow.com/questions/799981/document-ready-equivalent-without-jquery\n\n    // in case the document is already rendered\n    if (document.readyState != \'loading\') callback();\n    // modern browsers\n    else if (window.addEventListener) window.addEventListener(\'DOMContentLoaded\', callback);\n}\nfunction whenDocumentDependensHasLoaded(callback) {\n    if (document.readyState == \'complete\') callback();\n    // modern browsers\n    else if (window.addEventListener) window.addEventListener(\'load\', callback);\n}\n\nwhenDocumentTreeHasParsed(function () {\n    /*\n        文档加载完毕并且解析以后 ,及时保存 原始文本 ,避免被后面的 脚本 修改到\n        保持原始文本是为了方便后面进行 基于文本的定位\n    */\n    feelwithme.bodyVisibleText = document.body.innerText\n});\n\nwhenDocumentDependensHasLoaded(function () {\n    logger.info("whenDocumentDependensHasLoaded executing")\n    // reportInitialSizeAndPosition()\n    var oldBodyText = feelwithme.bodyVisibleText || ""\n    var newBodyText = document.body.innerText\n    if (newBodyText.length != oldBodyText.length) {\n        //  logger.info("body text has been change ! , old len : " , oldBodyText.length , "new len : " , newBodyText.length)\n        //  compareTwoText(oldBodyText , newBodyText)\n        feelwithme.bodyVisibleText = newBodyText\n    } else {\n        logger.info("body text does no change ...")\n    }\n\n    // 请求加载 anchor 列表 \n    readerOutput.loadAnchorsRequest()\n});\n\nfunction getBodyText() {\n    return feelwithme.bodyVisibleText\n}\n\nfunction whenStartRendering(callback) {\n    /*\n        readyState 等于 complete 才是真的加载完 js , images 等资源 ,权威 : https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState\n    */\n    // in case the document is already rendered\n    var debounceCallback = debounce(callback, 200, false)  //  immediate 必须是  false , 否则会\n    if (document.readyState != \'loading\') {\n        // logger.info("document readyState : " , document.readyState)\n        debounceCallback()\n        if (document.readyState == \'complete\') { // 加载完毕就没有必要走下面的 listener 了\n            return\n        }\n    }\n\n    // Alternative to load event\n    document.onreadystatechange = () => { // 如果 event 在 listen 前发生, 就无法再接收到了\n        logger.info(" document ready state : ", document.readyState)\n        if (document.readyState === "complete") {\n            // callback();\n            debounceCallback()\n        }\n    };\n}\n\n\n// whenStartRendering(function () {\n// readerOutput.onDocumentReady() documentReady 放这里不合适\n// whenDocSizeChanges()\n// reportInitialSizeAndPosition()\n// });\n\n\n\n\nfunction resetCurrentReadingScrollY(scrollY) {\n    feelwithme.readingLocate.scrollY = scrollY\n}\nfunction getCurrentReadingScrollY() {\n    return feelwithme.readingLocate.scrollY\n}\n\n/**\n * 重置 记录的 range \n * @param {Range} range 允许为 null\n * @param {*} msg \n */\nfunction resetCurrentReadingRange(range, msg) {\n    feelwithme.readingLocate.range = range\n    if (range != null) {\n        logger.debug("reset reading range , msg : ", msg || "", " rangeY : ", range.getBoundingClientRect().y, "range : ", range.startContainer, range.startOffset, range.endContainer, range.endOffset)\n    }\n}\nfunction getCurrentReadingRange() {\n    return feelwithme.readingLocate.range\n}\n\nreaderInput.delegateImpl.onScroll = function (x, y) {\n    logger.debug("receive x ", x, " , y  : ", y)\n    resetCurrentReadingScrollY(y)\n    // handleRotationIfNeed()\n    // clearReadingRangeIfNeed(y)\n    loadMarksIfNeed(y) // 允许 y == null 时调用 loadMarksIfNeed , 因为 某个 document 可能在可视区 且 scrollY 不在其范围内  \n    // fix bug : scrollY == null 的时候也要调用 notifyOnShowingAnchorChange ，让其他方法更新状态\n    notifyOnShowingAnchorChange(y)\n}\n\n\nfunction dfsNode(rootNode, forward, preOrder, beginPredict, filterPredict, handleFunc) {\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.DomHelper.shared.dfsNode(rootNode,forward,preOrder,beginPredict,filterPredict,handleFunc)\n}\n\n\nfunction createVisibleNodeFilterPredict(filterPredict) {\n    return function predict(node) {\n        if (FILTER_NODE_TYPES.indexOf(node.nodeType) == -1) {\n            return false\n        }\n        if (/SCRIPT|STYLE/.test(node.parentNode.tagName.toUpperCase())) {\n            // 不读取 script 和 style  , refer : https://stackoverflow.com/questions/54602331/handle-text-nodes-that-are-not-script-or-style-elements \n            return false\n        }\n        return filterPredict(node)\n    }\n}\n\n\n/**\n * 找到最靠近 scrollY 的 textNode 和 非 text类型的 node \n * 注意点 :\n *  rootNode 可能就在 scrollY 的下面 ,导致 nearestTextNode , nearestNode 均为 null \n * @param {Node} rootNode\n * @param {double} scrollY\n * @returns\n */\nfunction findNearestNodesByTop(rootNode, scrollY) {\n    var nearestTextNode = null\n    var nearestNode = null\n    var minValueOfNearestTextNode = 100000\n    var minValueOfNearestNode = 100000\n\n    var range = document.createRange();\n    var rect = null\n\n    var beginPredict = createVisibleNodeFilterPredict(function (node) {\n        return true\n    })\n    var filterPredict = function (node) {\n        range.selectNode(node)\n        rect = range.getBoundingClientRect();\n        if (scrollY < rect.top) {\n            return false\n        }\n        var recty = rect.y  // 不采用 rect.bottom 的原因 : 后期我们是根据 rect.y 作为 文档 偏移量 向 native 反馈的  \n        if (node.nodeType == 3) {\n            let distance = Math.abs(scrollY - recty)\n            if (distance < minValueOfNearestTextNode) {\n                nearestTextNode = node\n                minValueOfNearestTextNode = distance\n            }\n        } else {\n            let distance = Math.abs(scrollY - recty)\n            if (distance < minValueOfNearestNode) {\n                nearestNode = node\n                minValueOfNearestNode = distance\n            }\n        }\n        return true\n    }\n    var handleFunc = function (node) {\n        // 当 bottom  >= scrollY 的时候 , 说明 node 在 scrollY 下面 , 直接结束搜索\n        return scrollY <= rect.bottom\n    }\n\n    dfsNode(rootNode, true, true, beginPredict, filterPredict, handleFunc)\n\n    return {\n        nearestTextNode,\n        nearestNode\n    }\n}\n\n/**\n * match 的含义 :  node.y <= y && y < node.bottom\n *\n * 试着找到一个 rectangle 包含 scrollY 的 textNode  : matchTextNode\n * 如果找不到 ,就返回上一个最接近 scrollY 的 textNode :  nearestTextNode\n *\n * 同时, 找到一个 rectangle 包含 scrollY 的 非 textNode 的  matchNode\n * 如果找不到 , 就返回上一个最接近 scrollY 的 非 Node :  nearestNode\n *\n * 非 textNode 要 尽量都是最小粒度的 node\n *\n *\n * 为什么需要这样的考虑 :\n * 当我们保存用户阅读进度的时候 , 用户的阅读位置最好保存 为 "阅读到 哪一段文本"\n *      理由 : \n *          - 基于文本的定位可能更加可靠  . 而且可以跨域不同版本的电子书 , 后期更有用 \n *      极端 case : 极端情况下 , 是没有 textNode 的\n * \n * 但是当我们调整字体大小的时候 , 我们又需要一个 精确的 range ,以在调整字体以后 快速定位到之前阅读的位置 ,这个 range 就可以不是 textNode ,而是任何 node\n *\n * 总而言之 ,我们希望找到最好 的一个 node , 这个 node 匹配用户的阅读位置 ,或者最靠近用户的阅读位置 . 并且 ,这个 node 最好是 text ,这样方便后期 基于 文本的定位\n *\n *\n * 所有的 case 如下 :\n * textnode match scrollY\n * 没有 textnode match scrollY ,而是一个原子 node match 了 scrollY ,比如 image\n *\n * 没有任何的 node match scrollY , 那么就在 scrollY 的 **以上** 的 node 中查找最靠近的 node , 2个 case\n *      有 textNode.y 非常接近  scrollY\n *      有 普通Node.y 非常接近  scrollY\n * \n * \n * 补充说明 : \n *  matchNode 并不一定比  nearestTextNode 或者 nearestNode 更靠近 scrollY . 比如 : 当 match node 是 body 的时候 \n * @param {*} scrollY\n * @returns\n */\nfunction findMostMatchNodeForScrollPosition(scrollY) {\n    scrollY = parseInt(scrollY)\n    logger.debug("findMostMatchNodeForScrollPosition : ", scrollY)\n\n    var matchTextNode = null\n    var matchNode = null\n    var nearestTextNode = null // 用于在找不到合适的结果时 ,返回用户最后阅读的一个文本段\n    var nearestNode = null\n    var range = document.createRange();\n    var rect = null\n    var rectTop = null\n    var rectBottom = null\n\n\n    /*\n        采用 前序遍历  + child 从左到右的方式\n        先判断 parent 是否包含了 scrollY , 不包含直接跳过\n        从大到小不断缩小范围\n    */\n    var beginPredict = function (node) {\n        // range.selectNode(node)\n        // rect = range.getBoundingClientRect();\n        // return rect.y <= scrollY && scrollY < rect.bottom\n        return true // 上面注释掉的语句在 body 那一层就直接返回 true 了 ,这和直接返回 true 没啥区别\n    }\n    beginPredict = createVisibleNodeFilterPredict(beginPredict)\n\n    var filterPredict = function (node) {\n        // logger.debug("findMostMatchNodeForScrollPosition ,filterPredict : ",node.nodeName) \n        range.selectNode(node)\n        rect = range.getBoundingClientRect()\n        /*\n            不知道为什么 , 在 遍历了 很多 node 以后 , rectTop 应该只会越来越大的 . 但是后面有时会碰到一些 只有换行符的 textNode ,这些 textNode 的 rectTop,rectBottom 都是 0 \n                导致的后果就是 nearestTextNode 会被覆盖 . 所以 ,在这里过滤这些异常的 textNode\n        */\n        if (rectTop > parseInt(rect.top) && node.textContent != null && node.textContent.trim().length == 0 && rect.bottom < 1) {\n            return false;\n        }\n        rectTop = parseInt(rect.top)\n        rectBottom = parseInt(rect.bottom)\n\n        /*\n            注意点 : node 可能是一个 div 等 包含很多 child 的 element , 里面的 element 可能满足 filter 条件 .\n            所以 ,只有在 完全确认 node 及其 后代均不会 满足 filter 条件的情况下 ,才可以返回 false ,否则应该返回 true .\n            因为一旦 返回 false ,真个 node 及其 后代都会被 skip\n        */\n        if (scrollY < rectTop) { // [) 原则\n            // 可以确认 其 后代及其自身完全在 scrollY 线 的 下面 ,所以 过滤掉\n            // 注意点 : body 的 top 经常 不为0  , 大于 10 左右 . 所以 应该给 matchNode 一个默认值 \n            return false\n        }\n        if (rectBottom <= scrollY) {  // [) 原则\n            // 可以保证到  nearestTextNode , nearestNode 的 bottom 都是 <= scrollY\n            if (node.nodeType == TEXT_NODE_TYPE) {\n                nearestTextNode = node // 记录前一个 textNode\n                // range.selectNode(node)\n                // rect = range.getBoundingClientRect();\n            } else {\n                nearestNode = node\n                // rect = node.getBoundingClientRect();\n            }\n        }\n        // if (node.nodeType === 1) {   // Node.ELEMENT_NODE = 1\n        /*\n            当 node 是一个 container  , 并且其 children 的高度大于 container 的时候 , childrent 的  getBoundingClientRect.bottom 会大于 node 的  getBoundingClientRect.bottom\n            举个例子 :\n                node 是一个 div , (0,100,100,200)\n                node 里面有个 <p> , 这个 p 包含的文本很长 ,远远超过了  node ,并且分为很多的行 ,导致 node overflow\n                这时候 , p.getBoundingClientRect.bottom  就会超过 200 , 比如\n            当 node 是一个 container  , 并且里面包含的 文本或者其他 element 的 高度大于 container 的时候 ,就会 overflow .\n            但是 , container 里面的 element , 比如 p 的 getBoundingClientRect 返回的 bottom 是会 远远 node.getBoundingClientRect.bottom\n            \n            所以,我们要先判断 node 的 getBoundingClientRect 的 范围 ,根据这个范围来决定是否 继续处理 其 children\n        */\n        // rect = node.getBoundingClientRect();\n        // }\n        return true\n    }\n    var handleFunc = function (node) {\n        // rect 已经被 filterPredict 计算过了 , 可以直接使用 \n        if (rectTop <= scrollY && scrollY < rectBottom) {\n            if (node.nodeType == TEXT_NODE_TYPE) {\n                matchTextNode = node\n                // logger.debug("find match text node : " , node)\n                return true // 因为 text node 没有 children ,所以 匹配了就是匹配 了\n            } else {\n                matchNode = node\n                // logger.debug("find match node : " , node)\n                // return true // 不返回 true 是为了 寻找更小 粒度 的  matchNode\n            }\n        }\n        var done = scrollY < rectTop   // 在 scrollY 下面的 element 不再考虑了,return true 直接结束遍历\n        if (done) {\n            logger.debug(" going to finish , node : ", node)\n        }\n        return done\n    }\n\n    dfsNode(null, true, true, beginPredict, filterPredict, handleFunc)\n\n    // 可能存在 nearestNode == null 的情况(比如 scroll >= 0 && 在 body 的上面 ) ,这时候给 body\n    // nearestNode = nearestNode || document.body // body 的 y 可能不是 0  ,我就看到过 是 y=24 的 , nearestNode 存在 == body 的  case\n\n\n    // 因为 nearestNode 可能是一个 包含 很多 element 的 node ,所以需要获取 其 内部 node\n    // var nested = findNearestNodesByTop(nearestNode, scrollY) // 因为 nearestNode 里面的 nearestTextNode 可能更加接近 scrollY\n\n    // 对这些 node 进行排序\n    // var nearestTextNodeArray = [nearestTextNode, nested.nearestTextNode]\n    function compareNearestNode(a, b) {\n        if (a == null) {\n            return b\n        }\n        if (b == null) {\n            return a\n        }\n        range.selectNode(a)\n        var distanceA = Math.abs(scrollY - range.getBoundingClientRect().y)\n        range.selectNode(b)\n        var distanceB = Math.abs(scrollY - range.getBoundingClientRect().y)\n        if (distanceA < distanceB) {\n            return -1\n        }\n        return 1\n    }\n    // nearestTextNodeArray = nearestTextNodeArray.sort(compareNearestTextNode)\n    // match node 为 body 的时候 ,并不会比 nearestTextNode 更靠近 scrollY\n    var candidateNodes = [matchNode, nearestTextNode, nearestNode].sort(compareNearestNode)\n\n    return {\n        matchTextNode,\n        candidateNode: candidateNodes[0]\n    }\n}\n\n\n\n/**\n * 从文档的前面一直遍历到后面,找到第一个包含 scrollY 在内 的 range\n * 如果找不到 ,就返回 一个 在 scrollY 之前的 range  (类似视频播放的时候 ,在用户观看记录的前几秒进行播放 ,以便用户能够回忆起来 )\n *\n * @param {double } scrollY\n */\nfunction findFirstRangeMatchScrollPosition(scrollY) {\n    var range = null\n    var tmp = findMostMatchNodeForScrollPosition(scrollY)\n    // logger.debug("findMostMatchNodeForScrollPosition res : " ,JSON.stringify(tmp))\n    if (!!tmp.matchTextNode) {\n        // 如果存在这个 textNode , 那么 设置 range 为 这个 textNode ,同时调整这个 range\n        logger.debug("ratation : matchTextNode : ", tmp.matchTextNode.textContent)\n        range = shrinkRangeOfTextNode(tmp.matchTextNode, scrollY)\n    } else {\n        var node = tmp.candidateNode || document.body  // 如果没有候选的话 \n        range = document.createRange()\n        if (node.nodeType == 3) {\n            let len = node.length\n            range.setStart(node, len - 1)\n            range.setEnd(node, len)\n        } else if (isBlockNode(node)) {\n            /*\n                不使用 range.selectNode(node) 的原因 : range.selectNode(node) 会导致 range.startContainer 变为 当前 node 的 parentNode .\n                如果此时 node.parentNode == document.body , 那么 从 range 转为 rangy 的 bookmark , 再转回 range 的时候 ,就会导致 range 变为选择 body.\n                简单说 : 就是  range.selectNode(node) 也是对的 . 错的只是: rangyRange 无法兼容 range 选中 block 类型的情况 . 因为 rangyRange 的 bookmark 是基于 字符串的(CharRange ).\n                    而 block node 没有任何字符串,导致定位失败 .\n            */\n            range.setStart(node, 0)\n            range.setEnd(node, 0)\n        } else {\n            range.selectNode(node)\n        }\n    }\n\n    // else if (!!tmp.matchNode) {\n    //     logger.debug("ratation : matchNode : " ,  getSimpleXpath(tmp.matchNode) )\n    //     range = document.createRange()\n    //     range.selectNode(tmp.matchNode)\n    // } else if (!!tmp.nearestTextNode) {\n    //     /*\n    //         要考虑到这个  nearestTextNode 可能包含大量的 文本 , 比如超过 1万个 字符 . 那么基于文本的定位就会出现性能问题 . 因为唯一定位字符串 >= 1万个字符\n    //         因为  nearestTextNode 的 bottom 总是 <= scrollY , 所以我们取最后一个字符作为定位符  \n    //     */\n    //     logger.debug("ratation : nearestTextNode : " , tmp.nearestTextNode.textContent)\n    //     range = document.createRange()\n    //     let len = tmp.nearestTextNode.length\n    //     range.setStart(tmp.nearestTextNode, len - 1)\n    //     range.setEnd(tmp.nearestTextNode, len)\n    // } else if (!!tmp.nearestNode) {\n    //     logger.debug("ratation : nearestNode : " , getSimpleXpath(tmp.nearestNode))\n    //     range = document.createRange()\n    //     range.selectNode(tmp.nearestNode)\n    // } else {\n    //     logger.debug("ratation : no match node : ")\n    //     range = document.createRange()\n    //     range.selectNode(document.body)\n    // }\n\n    return range\n}\n\n\nfunction shrinkRangeOfTextNode(textNode, scrollY) {\n    var range = document.createRange()\n    range.setStart(textNode, 0)\n    range.setEnd(textNode, textNode.length)\n    /*\n     * loop invariant :\n     *      range[left,right).getBoundingClientRect().bottom 应该总是 > lastScrollY\n     */\n    var left = 0\n    var right = textNode.length\n    var rect = null\n\n    while (right - left > 1) {\n        const mid = Math.floor((left + right) / 2);\n        range.setStart(textNode, left)\n        range.setEnd(textNode, mid)\n\n        rect = range.getBoundingClientRect()\n\n        if (rect.bottom > scrollY) {\n            right = mid\n        } else {\n            left = mid\n        }\n        if (right - left < 50) {\n            logger.debug("candidate text : ", range.toString())\n        }\n    }\n\n    /*\n        loop invariants : 现在 [left,right) 是正确的范围,所以需要更新 range\n        优化 :\n            首行的第一个字符 getBoundingrecclient 总是 到 前一行的 top 位置 ,所以取第2个字符\n    */\n    if (right < textNode.length) {\n        left++\n        right++\n    }\n    range.setStart(textNode, left)\n    range.setEnd(textNode, right)\n\n    logger.debug("candidate text final : ", range.toString())\n    // debugger;\n    return range;\n}\n\n\nfunction isWhiteStr(str) {\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.NaturalTextHelper.shared.isWhiteStr(ch) \n}\n\nfunction isSentenceBreakChar(ch) {\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.NaturalTextHelper.shared.isSentenceBreakChar(ch) \n}\n\n\n/**\n * 如果找到唯一的定位,就返回 位置 ,否则返回 -1\n * @param {*} text\n * @param {*} target\n * @returns\n */\nfunction getUniqueLocatorTextIndex(text, target) {\n    var index = text.indexOf(target);\n    if (index == -1) {\n        return -1;\n    }\n    var last_index_of = text.lastIndexOf(target);\n    return index == last_index_of ? index : -1\n}\n\n\n/**\n * 查找 b 字符串 在 a 字符串的位置 \n * 注意!!! : 只适合的情况 : b 如果在 a 中的话 ,和 a 的对应字符串只存在 {空格,换行符} 数量的差异 \n *           例如 : a  = "ab\\naabbc" , b = "baa"\n * @param {String} a \n * @param {String} b \n * @returns \n */\nfunction renderTextRelocate(a, b, i) {\n    var begin = -1\n    var end = -1\n    i = i || 0\n    var j = 0\n    var aLen = a.length\n    var bLen = b.length\n\n    for (; i < aLen && j < bLen;) {\n        if (a[i] != b[j]) {\n            if (isWhiteStr(b[j])) {\n                j++\n            } else {\n                i++\n            }\n        } else {\n            if (begin == -1) {\n                begin = i\n            }\n            i++\n            j++\n        }\n    }\n\n    end = i\n    return [begin, end]\n}\n\nfunction createCleanSelection() {\n    var sel = window.getSelection()\n    // 为什么要移除 ? 因为 有时候真的存在 range 在 Selection 里面 , 如果我们不先 移除 所有 range 就添加新的 range , 就会出现 undefined 的情况 \n    sel.removeAllRanges()\n    return sel\n}\n\n/**\n * 就是 让用户选中的 部分向2边扩展直到成为一个完整的句子  \n * 先 backward 后 forward \n * 注意点:\n *  会修改 selection instance \n */\nfunction expandToWholeSentence(sel,locatorText,beginIndex) {\n    var res = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.SelectionNaturalTextHelper.shared.expandToWholeSentence(sel,locatorText)\n    return {\n        locatorText : res.locatorText , \n        beginIndex : beginIndex + res.beginIndex \n    }\n}\n\n/**\n * 使用 refresh 标志位的原因 :\n *      有些结果 ，最好使用缓存 。 因为不使用缓存结果重新计算的话 ， 可能会导致 前后不一致的结果 。  \n * @param {*} refresh \n * @param {*} originalRange \n * @param {*} rangeText \n * @param {*} shouldRangeIntoSelection \n * @param {*} locatorMinLength \n * @returns \n */\nfunction createTextLocator(originalRange, rangeText, shouldRangeIntoSelection = true, locatorMinLength = 50) {\n    feelwithme.operationLocation.text = doCreateTextLocator(originalRange,rangeText,shouldRangeIntoSelection,locatorMinLength)\n    return feelwithme.operationLocation.text \n}\n\n/**\n * 不再给予 bodyText 不变 ,允许其变化\n * 我们的目的仅仅是为了找到一个 locatorText \n * \n * @param {Range} originalRange  就是 selectionText 对应的 range\n * @param {String} rangeText // range 对应的 渲染出来的文本 \n * @param {boolean} shouldRangeIntoSelection\n * @param {Number} locatorMinLength\n * @returns\n */\nfunction doCreateTextLocator(originalRange, rangeText, shouldRangeIntoSelection = true, locatorMinLength = 50) {\n    var no_exist = {\n        locatorVisibleText: "",\n        selectionVisibleOffset: 0, // 选择的文本在 定位文本的偏移量\n        selectionVisibleLen: 0,// 选择的文本在 定位文本的长度\n        uniqueIndex: 0, // locatorVisibleText 在 bodyText 的偏移量\n\n        sentenceOffset: 0, // 增加2个字段 \n        sentenceLen: 0,  //  增加2个字段\n    }\n    if (originalRange.startContainer == document.body.parentElement) {\n        // 如果 range 包含整个 body \n        return no_exist\n    }\n\n    var sel = createCleanSelection()\n    sel.addRange(originalRange)\n    var selectedText = sel.toString() // 神奇,竟然碰到 sel.toString() 等于 "" 的情况 ,明明 range 有文本  . 弄清楚原因了: selection 已有 range 的情况下 ,添加 originalRange 会出现 undefined 行为 ,所以需要先清理 Selection 里面的  range\n    var locatorText = selectedText\n    var beginIndex = 0\n    var commonAncester = findCommonAncestorByPath("block", [sel.anchorNode, sel.focusNode])\n    // 为了防止数量不够 , commonAncester 可以更上一级 , 或者干脆就是 body \n    var stop = false\n    const maxCharacters = 50  // 大概就是 10 个 word \n\n\n    var res = expandToWholeSentence(sel,locatorText,beginIndex)\n    locatorText = res.locatorText \n    beginIndex = res.beginIndex \n\n    var sentenceOffset = 0\n    var sentenceLen = locatorText.length\n\n    function getDepth(ancester, descendant) {\n        var depth = 0\n        while (descendant != null && descendant != ancester) {\n            depth++\n            descendant = descendant.parentNode\n        }\n        return depth\n    }\n\n    // range 的 startContainer , endContainer 是有序的 ,保持前后关系\n    var aDepth = getDepth(commonAncester, sel.getRangeAt(0).startContainer)\n    var bDepth = getDepth(commonAncester, sel.getRangeAt(0).endContainer)\n\n    var stop = false \n    function checkIfNeedToStop() {\n        stop = locatorText.length >= maxCharacters || (aDepth <= 0 && bDepth <= 0)\n    }\n\n    checkIfNeedToStop()\n    while (!stop) {\n        // 注意 ran 是会变化的 , 而且不是同一个 ran , 貌似是 immutable\n        var ran = sel.getRangeAt(0)\n        if (aDepth > bDepth) {\n            //aDepth 比 dDepth 深 ,所以需要优先 backward  \n            sel.setBaseAndExtent(ran.endContainer, ran.endOffset, ran.startContainer, ran.startOffset)\n            sel.modify("extend", "backward", "sentence");\n            var newText = sel.toString()\n            var newDepth = getDepth(commonAncester, sel.focusNode)\n            if (newDepth <= 0) {\n                aDepth = 0\n            } else {\n                if (newText.length == locatorText.length) {\n                    // expand 时发现文本长度没有增加 , 说明 expand  到极限了 \n                    aDepth = 0\n                } else {\n                    aDepth = newDepth\n                }\n                // 更新 所在的 偏移量 \n                var moveLen = newText.length - locatorText.length\n                beginIndex += moveLen\n                sentenceOffset += moveLen\n                locatorText = newText\n            }\n        } else {\n            sel.setBaseAndExtent(ran.startContainer, ran.startOffset, ran.endContainer, ran.endOffset)\n            sel.modify("extend", "forward", "sentence");\n            var newText = sel.toString()\n            var newDepth = getDepth(commonAncester, sel.focusNode)\n            if (newDepth <= 0) {\n                bDepth = 0\n            } else {\n                if (newText.length == locatorText.length) {\n                    // 说明 expand  到了极限了 \n                    bDepth = 0\n                } else {\n                    bDepth = newDepth\n                }\n                locatorText = newText\n            }\n        }\n        checkIfNeedToStop()\n    }\n\n\n    sel.removeAllRanges()\n    if (!!shouldRangeIntoSelection) {\n        // 恢复回之前选择的 range  \n        sel.addRange(originalRange)\n    }\n\n    return {\n        locatorVisibleText: locatorText,\n        selectionVisibleOffset: beginIndex, // 选择的文本在 定位文本的偏移量\n        selectionVisibleLen: selectedText.length,// 选择的文本在 定位文本的长度\n        uniqueIndex: -1, // 不要这个字段了 ,仅仅保留 (当初这个字段用于定位和计算阅读的百分比 )\n\n        sentenceOffset: sentenceOffset, // 增加2个字段 \n        sentenceLen: sentenceLen,  //  增加2个字段 \n    }\n}\n\n/**\n * 找到 range 在 bodyText (body.innerText) 对应的 开始位置 i\n        bodyText[i] , 应该对应 range 包含的第一个字符\n *    \n * \n *\n * @param {String} bodyText range 的(visible)文本内容肯定在 bodyText 里面\n * @param {Range} range  range\n * @param {String} rangeText\n */\nfunction findBeginIndexInBodyVisibleText(bodyText, range, rangeText) {\n    /*\n        考虑点 :  \n            range 的  startContainer 的类型:\n                textNode\n                    要求 bodyText[i] 必须和 beginNode的 textContent[startOffset] 对应上\n                    如果 i 对应不上 并且是空白字符 ,就要不断移动 直到对应上为止 . \n                非 textNode\n                    当遍历到这个 node 的时候 ,要求 body[i] 继续前进直到和 rangeTrext[0]相同为止 . \n \n \n        实现思路 : 在遍历 dom tree 的过程中移动 i 变量 . \n            在没有碰到 beginNode 以前\n \n     */\n\n    var beginNode = range.startContainer\n    var startOffset = range.startOffset\n    if (range.startContainer.nodeType != 3) {\n        beginNode = range.startContainer.childNodes[range.startOffset]\n        startOffset = 0 // 因为这个 beginNode 本身就代表的是结束 \n    } else {\n        beginNode = range.startContainer\n    }\n    var bodyLen = bodyText.length\n\n    /*\n        思路:\n            逐个 text node 进行遍历 , 增量进行\n    */\n    var i = -1; // range 在 bodyText 中已经匹配的位置 ,开始时肯定是不匹配的,所谓初始化为 -1   \n    var j = 0\n    var rawText = ""\n    var rawTextLen = rawText.length\n\n    var beginPredict = function (node) {\n        return true\n    }\n    var filterPredict = createVisibleNodeFilterPredict(function (node) {\n        return true\n    })\n\n    function moveWhenMatch(node) {\n        for (j = 0; j <= rawTextLen; j++) {\n            // 因为 bodyText 和 rawText 存在 { 空格 , 换行符 } 数量的差异 ,所以需要协调 i,j 的位置 \n            while (j < rawTextLen && i + 1 < bodyLen && bodyText[i + 1] != rawText[j]) {\n                if (isWhiteStr(rawText[j])) {\n                    j++\n                } else if (isWhiteStr(bodyText[i + 1])) {\n                    i++\n                } else {\n                    /*\n                        这种情况是存在的 ,最起码存在普通的 web 页面中\n                        有时候 js/css  会在 页面插入一些 文本 , 导致 node.textContent  的内容 和 我们旧保存的 bodyText 不同 .\n                        因为我们的 textLocation 定位是基于我们早前保存的 bodyText ,所以 任何的不匹配字符 都是后期 js,css 增加  的 ,我们跳过就可以了 .\n                        当然 ,如果碰到 js/css 把原有的内容 删除掉的情况 ,那就无解了 .\n                    */\n                    console.info("should not reach hear , new body text is in dome ")\n                    j++ // 只能够跳过 node 的 ,确实会出现这样的情况 ,比如 dom 在后期临时增加了一些字符(利用 css 增加 ) \n                }\n            }\n            // 此时 i+ 1 >= bodyLen || j >= rawTextLen || bodyText[i + 1] == rawText[j] \n            if (i + 1 < bodyLen && j < rawTextLen) {\n                // 说明相等了 , i 移动一步 \n                i++\n            }\n        }\n    }\n\n\n\n    var handleFunc = function (node) {\n        if (node.nodeType != 3 && node != beginNode) {\n            return false\n        }\n        if (node != beginNode) {\n            // textnode \n            rawText = node.textContent\n            rawTextLen = rawText.length\n            moveWhenMatch(node)\n            return false\n        } else {\n            // 此时 node 开始进入 range 的第一个 node \n            if (node.nodeType != TEXT_NODE_TYPE) {\n                // todo 这个分支没有测试 \n                while (i + 1 < bodyLen && bodyText[i + 1] != rangeText[0]) {\n                    i++\n                }\n            } else {\n                // 这个分支测试了 \n                // 这里不能采取和 node.nodeType != TEXT_NODE_TYPE 的原因是 :  bodyText[i+1] 一开始就 == rangetText[0] 也不能够说明是匹配的 ,比如 : axxabc 匹配的 range 为 abc\n                // rawTextLen = startOffset + 1 \n                rawText = node.textContent.slice(0, startOffset + 1)\n                rawTextLen = rawText.length\n                moveWhenMatch(node)\n\n            }\n            return true\n        }\n    }\n\n    dfsNode(null, true, true, beginPredict, filterPredict, handleFunc)\n    return i\n}\n\n\nfunction findIndexRangeInBodyVisibleText(bodyText, range, rangeText) {\n    var begin = findBeginIndexInBodyVisibleText(bodyText, range, rangeText)\n    if (begin == -1 || begin >= bodyText.length) {\n        return [-1, -1]\n    }\n    return renderTextRelocate(bodyText, rangeText, begin)\n}\n\n\n\nfunction getDisplayType(element) {\n    if (element.nodeType != 1) {\n        return ""\n    }\n    var cStyle = element.currentStyle || window.getComputedStyle(element, "");\n    return cStyle.display;\n}\n\nfunction isBlockNode(element) {\n    return getDisplayType(element).toLowerCase() == \'block\'\n}\n\n/**\n * 找到通往 root 的 路径 ,以 descendant 到 ascendant 的顺序 \n * @param {*} node \n * @param {*} includeSelf 路径是否包含当前节点 ,默认包含 . 理由 : range.startContainer 和 endContainer 已经是 parent 了 , 如果从他们的 parent 算起 ,粒度就太大了  \n * @param {Node} endNode exclusive 最好是  document.body.parentNode , 因为 body 下面的 2个 child 需要用到 body 作为 container  \n * @returns \n */\nfunction getAncestorPath(node, includeSelf = true , endNode = document.body.parentNode) {\n    var res = []\n    if (!includeSelf) {\n        node = node.parentNode;\n    }\n    /*\n        fix bug 共同祖先可能是 body \n    */\n    while (!!node) {\n        if (node == endNode ) {\n            break;\n        }\n        res.push(node)\n        // if (node.tagName == document.body.tagName) {\n        //     break;\n        // }\n        node = node.parentNode\n    }\n    return res\n}\n\n\n/**\n * 查找所有 nodes 列表的 的共同祖先,并且这个共同祖先符号 displayType\n * @param {*} displayType 可以为 null ，为 null 表示不做{inline,block}类型判断  \n * @param {*} nodes\n */\nfunction findCommonAncestorByPath(displayType, nodes) {\n    //nodes 必须是2个以上\n    var nodePath = getAncestorPath(nodes[0]).reverse()\n    //fix bug : caIndex = nodePath.length 是错误的, 在 loop 之前的 invariants 就 没有  hold true !\n    var caIndex = nodePath.length - 1\n\n    for (var i = 1; i < nodes.length; i++) {\n        let path = getAncestorPath(nodes[i]).reverse()\n        let end = Math.min(path.length, caIndex + 1)\n        for (var j = 0; j < end; j++) {\n            if (nodePath[j] != path[j]) {\n                // 说明 j-1是 共同的\n                if (j - 1 < caIndex) {\n                    caIndex = j - 1\n                }\n                break;\n            }\n        }\n    }\n    var commonAncester = nodePath[caIndex]\n    if (displayType) {\n        while (getDisplayType(commonAncester) != displayType) {\n            commonAncester = commonAncester.parentNode\n        }\n    }\n    return commonAncester\n}\n\n/**\n * 找到 node 所在 的 xpath \n * 以 body 作为 root , 同时不返回 root 的路径 , 比如 /body[1]/div[2] 只会返回 /div[2]\n * 为什么 ? 因为以  html 作为 root 的话 , containerXPath 就会是 /html[1], 这个 以 html 作为 container 的 bookmark  ,在 rangy 的 moveToBookemark 的实现里面有 bug\n *  暂时没有能力去修改 rangy 框架 ,只好选择以 body 作为 root .也算可以满足需求了 \n * @param {Element} node  // 要求 node 是 element 类型的 \n * @param {Element} rootNode \n * @returns \n */\nfunction getSimpleXpath(node, rootNode = document.body) {\n    /*\n        xpath 是 1 base ,从 1开始\n        构建 xpath ，只用路径 和 id 作为标识，且除了 id 属性，不允许其他地方再用 // ,只能用 /\n        例子:\n            //div[@id="id_div1_1"]/span[0] 有id的\n            //div[2]/div[2]/div[1]/span[1] 无 id 的\n            /HTML[1]/BODY[1]    : 有时候 ,就会直接定位到 body \n\n        注意!!!\n            这里默认以 body 作为 root ,所有 xpath 不会包含 body , findNodeByXpath 也是有同样的约定!\n    */\n\n    var path = ""\n    if (isSameTagName(node.nodeName, document.nodeName) ||\n        isSameTagName(node.nodeName, document.body.parentNode.nodeName)) {\n        return\n    }\n    while (node != null && node.nodeName != rootNode.nodeName) {\n        var id = node.getAttribute("id")\n        if (id) {\n            path = "//" + node.nodeName + "[@id=\\"" + id + "\\"]" + path\n            return path\n        }\n        var index = getSameTypeNodeIndex(node) + 1\n        path = "/" + node.nodeName + "[" + index + "]" + path\n        node = node.parentNode\n    }\n    return path\n}\n\nfunction getSameTypeNodeIndex(node) {\n    var i = 0;\n    var tagName = node.tagName\n    while ((node = node.previousSibling)) {\n        if (isSameTagName(node.tagName, tagName)) {\n            ++i;\n        }\n    }\n    return i;\n}\n\n\n\nfunction getSameTypeNodeByIndex(parent, index, tagName) {\n    // xpath 1 base ，从 1开始计算位置\n    for (var child = parent.firstChild, i = 0; child !== null; child = child.nextSibling) {\n        if (isSameTagName(child.tagName, tagName)) { // fixbug : P  != p 的 bug . 这个 bug 导致 mark 无法定位到具体的文档位置 \n            i++\n            if (i == index) {\n                return child\n            }\n        }\n    }\n    return null\n}\n\n\nfunction getSelectionVisibleText(sel, trim) {\n    if (!trim) {\n        return sel.toString()\n    }\n    return sel.toString().trim()\n}\n\nfunction getPercentRageByRange(range) {\n    var rect = range.getBoundingClientRect();\n    var y = rect.y\n    var totalHeight = getDocHeight()\n    var totalWidth = getDocWidth()\n    if (totalHeight == 0 || totalWidth == 0) {\n        return 0\n    }\n    /**\n     * 一般小说 ,都是 1,000,000 字数以内 一般一行不少于 10 字 , 不超过 1000 字 \n     * 屏幕宽度不超过 10,000\n     * 当 rowPercent 相等的时候 ,再比较 rect.x 的位置 , 所以 rect.x 需要除以 1000,000 \n     * 还存在的问题 : 由于 字体调整的缘故 , 同一个 mark 占据的 百分比 可能会出现 浮动 ,这个误差 不知道是否可以接受 .\n     * 最精准的 ,应该是基于 文本所在的位置 . \n     * 但是, 基于文本的位置 ,要求能够精准的定位 在 Document 的文本的具体位置 .\n     *  这个我暂时没有很确定能够做好, 不过后期应该是基于文本位置进行定位吧 .\n     */\n    var rowPercent = y / totalHeight\n    var colPercent = rect.x / totalWidth // 不基于 rect.x /1000000  时因为不同的屏幕尺寸 ,同一个位置的 rect.x 不同 ,而百分比则相对固定 \n    var res = rowPercent + colPercent / 1000000\n    return res\n}\n\n/**\n * 返回 range 所在的完整 文本 \n * @param {Range} range 用户选择的 range \n * @param {String} selectionText range 对应的渲染出来的文本 \n */\nfunction findWholeSentence(range, selectionText, shouldRangeIntoSelection) {\n    var loc = createTextLocator(range, selectionText, shouldRangeIntoSelection)\n    var sentenceText = loc.locatorVisibleText.substr(loc.sentenceOffset, loc.sentenceLen)\n    var sentenceOffset = loc.selectionVisibleOffset - loc.sentenceOffset\n    var partLength = loc.selectionVisibleLen\n    return {\n        sentenceText, sentenceOffset, partLength\n    }\n}\n\n\n\nfunction getTailMarkPositionY() {\n    if (feelwithme.tailMark == null) {\n        return null\n    }\n    // 找到\n    var range = findRangeForLocation(feelwithme.tailMark.location)\n    if (!range) {\n        return null\n    }\n    return range.getBoundingClientRect().y\n}\n\n/**\n * 尝试继续加载 mark \n * @param {double} y  允许为 null\n * @returns \n */\nfunction loadMarksIfNeed(y) {\n    if (feelwithme.loadMark.done) {\n        logger.debug("loadMarksIfNeed , done ")\n        return  // 已经加载完毕就不需要再加载了 \n    }\n\n    var scrollY = y || getCurrentReadingScrollY() || 0   // feelwithme.readingLocate.scrollY\n    logger.debug("loadMarksIfNeed , scrollY : ", scrollY)\n    var viewPortHeight = feelwithme.readerView.height || 1000\n    var tailMarkPositionY = getTailMarkPositionY() || 0\n    var percentRate = 0\n\n\n    if (scrollY + 3 * viewPortHeight < tailMarkPositionY) {\n        logger.debug("loadMarksIfNeed no need to load more marks")\n        return\n    }\n\n    if (!!feelwithme.tailMark && feelwithme.tailMark.percentRate != null) { // !!0 == false \n        percentRate = feelwithme.tailMark.percentRate\n    }\n\n    logger.debug("loadMarksIfNeed , rate : ", percentRate)\n    readerOutput.requestToLoadMarks(percentRate, feelwithme.loadMark.pageSize)\n}\n\nreaderInput.delegateImpl.gotoAnchor = function (anchorValue) {\n    var y = getPositionYOfAnchor(anchorValue)\n    if (y == null) {\n        return // 找不到 anchor 对应的位置 ,就是 anchor 不存在 ,所以无法跳转  \n    }\n    var docHeight = getDocHeight();\n    \n    reportInitialLocationInfo(docHeight, y)\n}\n\n\nfunction findSuitableElementsToObserve() {\n    var children = document.body.children\n    var items = [document.body]\n    // 需要用到 包含文本的 element的原因 : 这样调整字体的时候 , 这个 element 的大小才可以发生变化 . 而像图片这样的 ,调整字体不会引起图片大小变化\n    for (var i = children.length - 1; i > -1; i--) {\n        var item = children[i]\n        if (item.innerText.trim().length > 0) {\n            items.push(item)\n            break\n        }\n    }\n    if (items.length == 1 && children.length > 0) {\n        items.push(children[children.length - 1]) // 如果实在没有 包含文本的 node ,放个 其他的 node \n    }\n    return items // content 变大的时候 ,Safari的 body 会随着变大 , 但是 content 变小的时候 , Safari 的 body 不会变小  \n}\n\nfunction startListenDocumentSizeChange(callback) {\n    var elements = findSuitableElementsToObserve()\n    var obs = new ResizeObserver(entries => {\n        callback(entries, elements)\n    })\n    elements.forEach((x) => obs.observe(x))\n    feelwithme.resizeObserver = obs\n    // feelwithme.resizeObserver.observe(document.body.lastElementChild) // lastElementChild 的高度可能恒为 0 , 比如 空白的 span 标签 ,所以尺寸不会变 \n}\n\n/**\n * 追踪目前 滚动的时候 ,已经到达了哪个 目录项\n * @param {*} scrollY \n */\nfunction traceReachedAnchor(scrollY) {\n\n}\n\n/**\n * 判断 scrollY(用户滚动到的位置) 和 anchor 的位置 ,来决定 这个 anchor 是否正在被展示 . 如果 true ,返回这个 anchor , 否则返回 null \n * @param {double } scrollY \n * @param {double?} anchorIndex // 允许越界\n * @returns \n */\nfunction getAnchorOnShowing(scrollY, anchorIndex) {\n    var anchors = feelwithme.anchor.list\n    if (anchorIndex < 0 || anchorIndex >= anchors.length) {\n        return null\n    }\n    var anchorItem = anchors[anchorIndex]\n    var anchorY = getPositionYOfAnchor(anchorItem)\n    if (anchorY == null) {\n        return null\n    }\n\n    var reachLimit = feelwithme.viewPort.height || 500\n    var onShowing = anchorY <= scrollY\n    return onShowing ? anchorItem : null\n}\n\n/**\n * 找到匹配(显示在菜单上)的 anchor \n * 主要思路 :\n *      从上次匹配的位置 向两边搜索 \n * 注意 : 要求 feelwithme.anchor.list 按照位置大小排好序 \n * @param {double} scrollY \n */\nfunction findReachAnchorIndex(scrollY) {\n    if (scrollY == null) {\n        return null\n    }\n    var currentIndex = feelwithme.anchor.lastIndex || 0\n    var anchors = feelwithme.anchor.list\n    var anchorLen = anchors.length\n\n    /*\n     * 为什么没有 anchor 也要返回  "" ? \n     *      因为我们需要让外界知道滚动到了 哪个 document  ...\n     */\n    if (anchorLen == 0 ) {\n        return ""\n    }\n    var reachLimit = feelwithme.viewPort.height || 500\n    var match = null\n    var i = currentIndex\n\n    /*\n        从 feelwithme.anchor.lastIndex 先往后找 , 最后匹配的优先 , 比如 {a,b,c } 都匹配了 , 那么 c 就是当前的 目录\n    */\n    while (i < anchorLen) {\n        var anchor = anchors[i]\n        var y = getPositionYOfAnchor(anchor)\n        // logger.debug("findReachAnchorIndex , anchor i : " , i , "anchor : ", anchor , " , y  : " , y , "visible y : " , scrollY + reachLimit) \n        if (y == null) {\n            continue\n        }\n        if (y < scrollY + reachLimit) {\n            match = anchor // 如果后面还有章节已经被展示出来 , 那么 说明 i 所代表的 chapter 不是最新的 ,所以需要继续向后遍历 \n            feelwithme.anchor.lastIndex = i\n            // 不 break 是为了不断向后查找 \n            // logger.debug("match one anchor , anchor : " ,anchor )\n        }\n\n        i++\n    }\n    if (match != null) {\n        return match\n    }\n\n    /*\n        向前找 , 一旦找到马上 break . 因为 目录定位中 , 最后的目录匹配优先级最高 : {a,b,c} 均匹配 ,那么 取 c \n    */\n    i = currentIndex - 1 // 因为前面已经考虑到  currentIndex 了 \n    while (i != -1) {\n        var anchor = anchors[i]\n        var y = getPositionYOfAnchor(anchor)\n        if (y == null) {\n            continue\n        }\n        // logger.debug("findReachAnchorIndex , anchor i : " , i , " , y  : " , y ) \n        if (y < scrollY + reachLimit) {\n            match = anchor\n            feelwithme.anchor.lastIndex = i\n            break // 在后面的 章节一旦展示出来 ,说明已经到这个章节了 , 所以要 break \n        }\n        i--\n    }\n\n    return match\n\n    // var stop = false\n    // var match = null\n    // while(!stop){\n    //     var i =  currentIndex - delta  // 不 -1 是为了 把 当前  currentIndex 也纳入考虑\n    //     var j =  currentIndex  + delta + 1\n    //     var k = j // k 用于标记 匹配的位置 \n    //     // 先从 后面 的 anchor 开始判断 , 保证 高亮的 anchor 是单调变化 的 \n    //     match = getAnchorOnShowing(scrollY , j)\n    //     if ( match == null ){\n    //         match = getAnchorOnShowing( scrollY , i ) \n    //         k = i\n    //     }\n    //     if ( match != null){\n    //         feelwithme.anchor.lastIndex = k\n    //         return match\n    //     }\n    //     stop = i < 0 && j >= anchorLen // i , j 任意一个越界都没有关系 , getAnchorOnShowing 会考虑越界问题 \n\n    //     delta++ // ... 忘记了这一步 ,导致死循环 \n    // }\n    // return null\n}\n\nfunction notifyOnShowingAnchorChange(scrollY) {\n    /*\n        为 null 的时候也要更新 ，不更新的话，用户滚到下一个doc 后再滚回来 ，由于 lastValue 还是原值，导致认为不需要更新，那就出 bug 了 。 \n     */\n    var anchor = findReachAnchorIndex(scrollY)\n    if (feelwithme.anchor.lastValue != anchor){\n        // 如果是和上次的一样，就没有必要发送消息了 ，减少不必要的工作  \n        feelwithme.anchor.lastValue = anchor\n        if (anchor != null){\n            // anchor 为 null 的时候 ，也要更新 lastValue , 只是不需要告诉 native 而已 .\n            readerOutput.onAnchorReachRequest(anchor)\n        }\n    }\n}\n\nreaderInput.delegateImpl.loadAnchorsResponse = function (anchors) {\n    var ah = []\n    anchors.forEach(anchor => {\n        var y = getPositionYOfAnchor(anchor)\n        if (y != null) { // 放弃为 null 的 , 为 null 应该就是这个 anchor 不存在 \n            ah.push({ anchor, y })\n        }\n    });\n    if (ah.length == 0) {\n        return\n    }\n\n    function compareAnchor(a, b) {\n        return a.y - b.y\n    }\n    ah.sort(compareAnchor)\n    feelwithme.anchor.list = ah.map((x) => x.anchor)\n\n    // 更新 当前 anchor \n    notifyOnShowingAnchorChange(getCurrentReadingScrollY())\n}\n\nreaderInput.delegateImpl.changeFontSize = function (fontSize) {\n    var range = feelwithme.readingLocate.range\n    var scrollY = getCurrentReadingScrollY()\n    if (range == null) {\n        if (scrollY != null) {\n            range = findFirstRangeMatchScrollPosition(scrollY)\n            // feelwithme.readingLocate.range = range\n            resetCurrentReadingRange(range)\n        }\n    }\n\n    readerInput.setFontSize(fontSize)\n}\n\nreaderInput.delegateImpl.unfreezeReadingRange = function () {\n    /*\n        feelwithme.readingLocate.range 固定住用户当时阅读的位置,以方便 调整文档的 font-szie\n        当用户不再调整 font-size 等 ,而是开始滚动 阅读的时候 ,就要清空这个 range .防止下次定位用到这个旧的 range \n    */\n    // feelwithme.readingLocate.range = null\n    resetCurrentReadingRange(null)\n}\n\nreaderInput.delegateImpl.changeMode = function (isDark) {\n    var container = document.documentElement\n    var darkModeClass = "darkMode"\n    if (isDark) {\n        if (container.classList.contains(darkModeClass)) {\n            return\n        }\n        container.classList.add(darkModeClass)\n    } else {\n        container.classList.remove(darkModeClass)\n    }\n}\n\nfunction createInVisuableContainer() {\n    /*\n            chatgpt 提供的参考...\n        */\n    var containerElement = document.getElementById("hiddenForRender");\n    if (!containerElement) {\n        var containerElement = document.createElement("div")\n        containerElement.setAttribute("id", "hiddenForRender")\n        // containerElement.setAttribute("style","display: none")\n        // containerElement.setAttribute("style","opacity: 0.0;")\n        // containerElement.setAttribute("style","opacity: 0.0;width: 1px,height:1px")\n        containerElement.setAttribute("style", "opacity: 0.0;position: absolute;  left: -999999px;")\n        var body = document.body\n        body.appendChild(containerElement)\n    }\n    return containerElement;\n}\n\nfunction getRenderedTextOfNode(node, clone = true) {\n    if (clone) {\n        node = node.cloneNode(true)// 如果不clone，就相当于把node节点插入到了containerElement这里,后面又把 containerElement 里面的内容清除，会导致 node.parentNode 为 null 的\n    }\n    var containerElement = createInVisuableContainer()\n    containerElement.appendChild(node)\n    var renderedText = containerElement.innerText\n    containerElement.innerHTML = \'\'\n    return renderedText\n}\n\nfunction getVisibleTextOfRange(range) {\n    /*\n        rangyRange.text() 获取的文本，和浏览器的 document.body.innerText 存在一些差距 (rangyRange 多了一些空格，浏览器没有空格)\n        nativeRange toString() 返回的文本，也不是 visible text ,所以也无法用.  \n\n        而用 getRenderedTextOfNode 的方式，是直接把node 插入到 document 的隐藏节点进行渲染的，所以能够尽最大可能和浏览器保持一致\n        todo : 测试是否可以让 selection 变得透明 ,可以的话就用 selection \n    */\n    var fragment = range.cloneContents()\n    return getRenderedTextOfNode(fragment, false)\n}\n\n\n// init ---------------------------------\nfunction observeDocumentSizeWaitingTimeSupplier() {\n    var times = -1\n    var accInterval = 0\n    return function () {\n        times++\n        var intervalValue = 10\n        //  intervalValue 在不同的时间段,分配的大小不同 ,最开始就允许频繁反馈 ,后面慢慢拉长为固定值 \n        if (accInterval <= 200) {\n            intervalValue = 20 // 让其快速反馈 ,迅速调整好文档位置\n            accInterval += intervalValue\n        } else if (accInterval <= 500) {\n            intervalValue = 200\n            accInterval += intervalValue\n        } else {\n            intervalValue = 200 // 200 吧 , 因为从实际体验下来 , 2000延时太大,用户调整完了自己得等好久 \n        }\n        return intervalValue\n    }\n}\n\n\nfunction isInRange(range, scrollY) {\n    if (range == null || scrollY == null) {\n        return false\n    }\n    /*\n        因为浮点数的问题 \n        rect.y :  12052.515625  scrollY :  12052.5 ,导致 rect.y <= scrollY 失败 \n    */\n    var rect = range.getBoundingClientRect()\n    var rectTop = parseInt(rect.top)\n    var rectBottom = parseInt(rect.bottom)\n    scrollY = parseInt(scrollY)\n    // logger.debug("isInRange , rectTop,rectButtom" , rectTop,rectBottom , " scrollY : " , scrollY)\n    return rectTop <= scrollY && scrollY < rectBottom\n}\n\nreaderInput.delegateImpl.handleScreenRotationBefore = function (scrollY) {\n    /*\n        fixbug 必须用  feelwithme.readingLocate.range, 而不是 feelwithme.screenRotation.range 来进行记录 .\n        因为根据日志 ,我们发现旋转的时候 whenDocSizeChanges 函数会被调用 ,传递的 lastScrollY > docSize ,导致 不准确.\n        而之所以 whenDocSizeChanges 得到   lastScrollY > docSize 的 数据 ,具体原因不清楚 . 但是 如果我们把  feelwithme.readingLocate.range 赋值的话 ,\n        whenDocSizeChanges 就会用到这个 range ,就不会出现   lastScrollY > docSize 的情况 .\n        另一种 解决方案就是 :  whenDocSizeChanges 检查发现 lastScrollY > docSize 时说明数据异常 ,直接退出函数而不是继续执行 .\n    */\n    // if (feelwithme.screenRotation.range != null){ \n    var range = feelwithme.readingLocate.range\n    scrollY = getCurrentReadingScrollY()\n    if (isInRange(range, scrollY)) {\n        // logger.debug("isInRange , no need to update range ")\n        return // 不需要更新\n    }\n    // if (feelwithme.readingLocate.range != null){ \n    // 为什么这样写 ,是因为 第一次 rotation 以后 , 可能没有调用 handleScreenRotationAfter 进行阅读位置修复 \n    // return \n    // }\n    // scrollY = getCurrentReadingScrollY()\n    // 更新 range \n    range = findFirstRangeMatchScrollPosition(scrollY)\n    // logger.debug("range of y : " , scrollY , " : ",range.startContainer, range.endContainer)\n    // feelwithme.readingLocate.range = range\n    resetCurrentReadingRange(range, "rotation , docHeight : " + getDocHeight() + " , scrollY " + scrollY,)\n    // logger.debug("ratation : handleScreenRotationBefore scrollY : " ,scrollY , "range-y : " , range.getBoundingClientRect().y  , "range-startContainer : " , getSimpleXpath(range.startContainer) , "range : " , range.toString())\n\n    // 没想到之前的 whenDocSizeChanges 函数那么巧妙通用,所以不需要写定时 timeout 了 ,真棒!\n    // 为什么这样做 ? 因为 handleScreenRotationAfter 可能不会被触发 ,导致 用户旋转以后 阅读位置没有得到矫正 ,这里视图手动矫正 \n    // clearTimeout(feelwithme.screenRotation.timeoutId)\n    // feelwithme.screenRotation.timeoutId = setTimeout(function(){ \n    //     console.log("try to fix reading position using timeout")\n    //     readerInput.delegateImpl.handleScreenRotationAfter()\n    // }, 200);\n    // reportInitialLocationInfo(getDocHeight(),range.getBoundingClientRect().y)\n}\n// readerInput.delegateImpl.handleScreenRotationAfter = function(scrollY){\n//     var range = feelwithme.readingLocate.range\n//     if (range != null){\n//         var docHeight = getDocHeight()\n//         logger.debug("ratation : handleScreenRotationAfter scrollY : " , range.getBoundingClientRect().y ,"doc height : " ,docHeight)\n//         feelwithme.readingLocate.range = null\n//         reportInitialLocationInfo(docHeight , range.getBoundingClientRect().y)\n//     }\n// }\n// function handleRotationIfNeed(){\n//     readerInput.delegateImpl.handleScreenRotationAfter()\n// }\n\nreaderInput.delegateImpl.reportTrueReadingProgressInfo = function (scrollY) {\n    scrollY = Number(scrollY.toFixed(0)) // 四舍五入 ,只保留整数  \n    var docHeight = Math.floor(getDocHeight())\n    var result = 0\n    if (docHeight == 0) {\n        result = 0\n    }\n    if (scrollY > docHeight) {\n        scrollY = docHeight\n    }\n    result = Math.floor(scrollY) / Math.floor(docHeight)\n    readerOutput.onReportTrueReadingProgressInfo(result)\n}\n\n\nwhenDocumentDependensHasLoaded(function () { startListenDocumentSizeChange(throttle(whenDocSizeChanges, observeDocumentSizeWaitingTimeSupplier(), { leading: false })) })\n\n\nlogger.debug("basic.js load success")\n\n// import { KeepRangeFlag } from "./helpers"\n\n\nreaderInput.delegateImpl.requestTranslateTexts = () => {\n    var sel = window.getSelection()\n    /*\n        2 种情况 : 用户点击选择的 selection  ， 用户点击 mark  \n    */\n    if (sel.rangeCount > 0){\n        readerOutput.responseTranslateTexts(\n            _helpers_js__WEBPACK_IMPORTED_MODULE_0__.SelectionNaturalTextHelper.shared.selectCurrentWord(),\n            _helpers_js__WEBPACK_IMPORTED_MODULE_0__.SelectionNaturalTextHelper.shared.selectCurrentSentence(),\n            _helpers_js__WEBPACK_IMPORTED_MODULE_0__.SelectionNaturalTextHelper.shared.selectCurrentParagraph()\n        )\n        return \n    } \n\n    // 用户没有选择 selection ，而是点击 mark  \n    var  range = null\n    var highlight = feelwithme.lastHighlight\n    if (highlight != null) {\n        range = highlight.getRange().nativeRange\n        if (range == null) {\n            readerOutput.responseTranslateTexts("", "", "")\n            return\n        }\n        sel.addRange(range)\n    }\n    var word = ""\n    var sentence = ""\n    var paragraph = ""\n    var getTexts = function (sel) {\n        word = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.SelectionNaturalTextHelper.shared.selectCurrentWord(),\n            sentence = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.SelectionNaturalTextHelper.shared.selectCurrentSentence(),\n            paragraph = _helpers_js__WEBPACK_IMPORTED_MODULE_0__.SelectionNaturalTextHelper.shared.selectCurrentParagraph()\n    }\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.SelectionHelper.shared.operate(sel, range, "", _helpers_js__WEBPACK_IMPORTED_MODULE_0__.KeepRangeFlag.EMPTY, getTexts)\n    readerOutput.responseTranslateTexts(word, sentence, paragraph)\n}\n// 使用的 feelwithme 空间\nfeelwithme.highlightIdToMarkId = {}\nfeelwithme.markIdTohighlightId = {}\n\nfunction isPointInRect(rect , x , y ){\n    const diffX = x - rect.x\n    const diffY = y - rect.y\n    return  0 <= diffX && diffX < rect.width && 0 <= diffY && diffY < rect.height\n}\n\n/**\n * 当 click 不是 点在 用户的 selection (window.getSelection ) 上面的时候 , 触发 fn 方法\n * @param {UIEvent} startEvent click/tap 对应的 开始  event\n * @param {UIEvent*} endEvent  click/tap 对应的 end  event\n * @param {*} fn\n * @returns\n */\nfunction callWhenIsClickOnNonSelectionArea(startEvent, endEvent, fn) {\n    const timeDiff = Math.abs( startEvent.timeStamp - endEvent.timeStamp ) // 毫秒为单位\n    if (timeDiff >= 200) {  // 如果时间过长 ,就很有可能导致 新的 selection 产生\n        return\n    }\n    const diffX = Math.abs( startEvent.pageX - endEvent.pageX )\n    const diffY = Math.abs( startEvent.pageY - endEvent.pageY )\n    \n    const distanceIsSmall = diffX <= 10 && diffY <= 10\n    if (!distanceIsSmall){\n        return\n    }\n//    const sel = window.getSelection() // 前面的长按可能导致 产生新的 Selection // 这个 获取 selection 进行比较的方法是错误的 ,如果真的需要这样做 ,就要那旧的 Selection 和 当前的 selection 比较 ,看看是不是同一个 , 如果不是 ,说明由于长按 ,导致新的 selection 产生 .\n//    if (sel.rangeCount != 0 || sel.getRangeAt(0).isCollapsed == false ) {\n//        return\n//    }\n    fn(endEvent)\n}\n\nfunction onNewSelectionCreate(callback) {\n    document.addEventListener("touchend", function (e) {\n        const sel = window.getSelection()\n        const rect = sel.getRangeAt(0).getBoundingClientRect()\n        if (sel.isCollapsed || !isPointInRect(rect, e.pageX, e.pageY)) {\n            // 当 touchend 结束的时候 , (pageX,pageY) 不在 选中区 , 说明没有创建新的 Selection ,而是点击了别的 地方, 准备取消 Selection\n            // 错误 : 用户有时候把手滑的老远 ,但是文本很短 ,这时候,文本已经选了 ,但是 touchend 的 pageX,pageY 却不在 选择的文本的 rect 内\n            return\n        }\n        callback()\n    }, false);\n}\n\nfunction WhenUserInteract(selectionExistHandle, clickEmptyFunc) {\n    var self = this\n    self.startEvent = null\n    self.endEvent = null\n    // this.callback = callback\n    // todo : 后期支持 PC 版本的话 ,需要把 touchstart , touchend 分别换位 mousedown , mouseup\n    document.addEventListener("touchstart", function (e) {\n        self.startEvent = e\n    })\n    document.addEventListener("touchend", function (e) {\n        self.endEvent = e\n\n        const sel = window.getSelection()\n        if (sel.rangeCount == 0) {\n            // clickEmptyFunc(e)\n            // callWhenIsClickOnNonSelectionArea(self.startEvent,self.endEvent , clickEmptyFunc)\n            return\n        }\n        const rect = sel.getRangeAt(0).getBoundingClientRect()\n        // 之所以要求 start , end 中的任意一个 必须在 Selection 的范围内 ,是因为 只要任意一个在 ,就算还在 select 中.\n        const touchInRect = isPointInRect(rect, self.startEvent.pageX, self.startEvent.pageY) || isPointInRect(rect, e.pageX, e.pageY)\n        if (sel.isCollapsed || !touchInRect) {\n            // 当 touchend 结束的时候 , (pageX,pageY) 不在 选中区 , 说明没有创建新的 Selection ,而是点击了别的 地方, 准备取消 Selection\n            // 错误 : 用户有时候把手滑的老远 ,但是文本很短 ,这时候,文本已经选了 ,但是 touchend 的 pageX,pageY 却不在 选择的文本的 rect 内\n            // clickEmptyFunc(e)\n            // callWhenIsClickOnNonSelectionArea(self.startEvent,self.endEvent , clickEmptyFunc)\n            return\n        }\n        selectionExistHandle(e)\n    })\n    // callWhenIsClickOnNonSelectionArea 在 touch 的计算有bug : 当点击高亮地方的时候 ,由于高亮地方不是 selection .导致 触发  clickEmptyFunc.\n    // 而我们预期的是 : 触发 clickMark 就够了 , 但是 callWhenIsClickOnNonSelectionArea 额外触发了 clickEmptyFunc\n    // 因此 ,不通过 touch 去处理 clickEmptyFunc , 而是通过单独的 click  event \n    document.addEventListener("click" , function (e) {\n        if (isClickOnLink(e.target)) {\n            // 点击 link 的时候 , 不需要  toggle 控制栏(navigationBar,tabBar ) 等 , 所以不需要执行  clickEmptyFunc\n            // 有时候 , <a> 标签下面还有子标签  \n            return \n        }else if (e.target.tagName.toLowerCase() == "img" && e.target.src.length > 0){\n            readerOutput.onClickImage(e.target.src)\n            return \n        }\n        clickEmptyFunc(e)\n    })\n    return self\n}\n\nfunction isClickOnLink(ele){\n    while(ele != null && ele != document.body){\n        if (ele.nodeName.toLowerCase() == "a"){\n            return true\n        }\n        ele = ele.parentNode \n    }\n    return false \n}\n\nfunction onUserTouchNewSelection(e){\n    var sel = window.getSelection()\n    if (sel == null || sel.rangeCount == 0 || sel.isCollapsed \n        || sel.toString().trim().length < 1){ // 选择空白 字符串的情况 : 用户选中一个 图片 ,就会弹出 editingMenu \n        // 不存在 selection\n        return\n    }\n    var rect = sel.getRangeAt(0).getBoundingClientRect()\n    var selectedRenderText = sel.toString()\n    var wholeSentence = findWholeSentence(sel.getRangeAt(0) , selectedRenderText , true )\n    readerOutput.onNewSelectionExist( rect , selectedRenderText , wholeSentence)\n}\n\nfunction onClickNonSelectionArea(e){\n    var point = {x : e.pageX , y : e.pageY }\n    readerOutput.onClickNonSelectionArea( point )\n}\n\nfunction getRectForSelectedText(elm) {\n    if (typeof elm === "undefined") elm = window.getSelection().getRangeAt(0);\n\n    var rect = elm.getBoundingClientRect();\n    return { x: rect.left, y: rect.top, width: rect.width, height: rect.height }\n}\n\nfunction onClickMark(markId,  rect , selectedText , sentence , hasNote ) {\n    readerOutput.onClickMark(markId , rect ,selectedText ,sentence , hasNote )\n    // var urlBase = "marker://feelwith.me?params=";\n    // window.location = urlBase + objToBase64Url(params);\n    // readerMessageHandler.sendSuccessMessage("onClickMarker",params)\n}\nfunction changeMarkStyle(markClass){\n    if (feelwithme.lastHighlight == null ){\n        // 不存在当前高亮 , 没有可以高亮的地方  \n        return \n    }\n    var classApplier = rangyHighlighter.classAppliers[markClass] \n    if (classApplier == null ){\n        return \n    }\n    feelwithme.lastHighlight.changeClassApplier(classApplier)\n\n    // 通知 app 修改的是哪个 mark \n    var markId = getMarkerId( feelwithme.lastHighlight.id ) \n    if (!!markId ){\n        readerOutput.onMarkClassChange(markId , markClass )\n    }\n}\n\n\n/**\n * \n * @param {*} markId \n * @param {*} markClass \n * @param {*} isNoting true : 是 笔记 ,  false : 仅仅是 标记 \n * @returns \n */\nfunction highlightSelection(markId, markClass , isNoting ){\n    var rangySel = _lib_rangy_core_js__WEBPACK_IMPORTED_MODULE_1__.rangy.getSelection()\n    var sel = rangySel.nativeSelection\n    var rangyRange = rangySel.getRangeAt(0)\n    // var originalRange = rangyRange.nativeRange.cloneRange();\n    var originalRange = sel.getRangeAt(0).cloneRange ()\n\n    /*\n        产生交集 或者 连续的 highlight 可能 class 相同,也可能不同\n        用户 选择 的 range 可能和多个 highlight 产生: 连续,交叉,包含 的关系 \n        这时候 ,我们需要用 第一个 highlight 的 class 作为默认高亮的 class \n    */\n    var toRemoveHighlights = getToMergeHighlight(rangyRange)\n    var toHighlightCharRange = getToMergeCharRange(toRemoveHighlights, rangyRange)\n    // 删除存在 交集||连续的 Highlight\n    rangyHighlighter.removeHighlights(toRemoveHighlights)\n    var removeMarkIds = toRemoveHighlights.map((x) => getMarkerId(x.id))\n    removeMarkIds = cleanRemoveMarkId( markId ,removeMarkIds) // 因为 Selection 在 新建 note 以后并不会消失 ,导致我们认为是又有新的 Selection (delegateImpl.addNote) , 所以 会把已经存在的 markId 作为需要合并移除的 mark\n    // 高亮 合并的 CharRange . 设置高亮以后 , 会导致 selection 消失 ,原因是因为 range 对应的 dom 结构已经被破坏了 (因为高亮 插入了 一个 <span> )\n    var newHighlightList = rangyHighlighter.highlightCharacterRanges(markClass, [toHighlightCharRange])\n    var newHighlight = newHighlightList[0]\n    // 记录当前的高亮\n    feelwithme.lastHighlight = newHighlight\n    // 更新 是否有 note 的标志 \n    setHasNoteIfNeed(newHighlight , toRemoveHighlights , isNoting )\n    //变更注册信息\n    changeRegisterInfo(markId, newHighlight, toRemoveHighlights)\n    let highlightRange = newHighlight.getRange().nativeRange\n    var text = getHightlightRenderText(sel , originalRange , highlightRange) \n    var location = createCompositLocatorForRange(highlightRange , text ,false,true)\n    // 百分比的计算有2种途径 : 基于文本 \\ 基于 视觉高度 ,现在先选择视觉高度吧\n    var percentRate = getPercentRageByRange(highlightRange)\n    // 传递高亮信息\n\n    return {markId , markClass , removeMarkIds , percentRate , location , text , isNoting}\n}\n\nfunction cleanRemoveMarkId(newMarkId , removeMarkIds ){\n    removeMarkIds = removeMarkIds || []\n    removeMarkIds = removeMarkIds.filter(function(item) {\n        return item !== newMarkId\n    })\n    return removeMarkIds\n}\n\n\n// function getHighlightLocation(standardSel,userSelectedStandardRange,highlightRange){\n//     var hightlightRenderText = getHightlightRenderText(standardSel , userSelectedStandardRange , highlightRange) \n//     return createCompositLocatorForRange( highlightRange ,hightlightRenderText )\n// }\nfunction getHightlightRenderText(standardSel , userSelectedStandardRange , highlightRange){\n        /*\n        为了获取合并之后 Highlight 的 visible text ,只好暂时修改 Selection 的 range ,祈祷用户没有感知到.\n        假如用户感知到的话,希望意见也不大. \n\n        获取完毕之后,我们会马上回复回原来用户选择的那段文本\n        */\n        standardSel.removeAllRanges()\n        standardSel.addRange(highlightRange)\n        var highlightVisibleText = getSelectionVisibleText(standardSel)\n        standardSel.removeAllRanges()\n        standardSel.addRange(userSelectedStandardRange)\n\n        return highlightVisibleText \n}\n\nfunction setHasNoteIfNeed(newHighlight , removeHighlights , isNoting ){\n    var hasNote = isNoting || newHighlight.hasNote\n\n    if (!hasNote && removeHighlights) {\n        // 检查替换的是否有 笔记(note)\n        hasNote = removeHighlights.filter((x) => x.hasNote = true).length != 0\n    } \n    newHighlight.hasNote = hasNote \n}\n\nfunction getToMergeHighlight(rangyRange) {\n    var contiguousHighlights = getContiguousHighlights(rangyHighlighter, rangyRange)\n    var insectedHighlights = rangyHighlighter.getHighlightsInSelection() || []\n    return contiguousHighlights.concat(insectedHighlights)\n}\n\nfunction getContiguousHighlights(highlighter, rangyRange) {\n    /*\n        获取 和当前的 rangyRange 存在首尾连接的 highlight\n\n        注意:  CharRange 的 isContiguousWith 方法比较的是在同一个 container 的 charRange ,具体可以看 实现\n     */\n    var res = []\n    var charRange = highlighter.converter.rangeToCharacterRange(rangyRange)\n    var highlights = highlighter.highlights\n    for (var j = 0; j < highlights.length; ++j) {\n        var highlightCharRange = highlights[j].characterRange;\n        if (highlightCharRange.isContiguousWith(charRange)) {\n            res.push(highlights[j])\n        }\n    }\n    return res\n}\n\nfunction getToMergeCharRange(toRemoveHighlights, rangyRange) {\n    var toHighlightCharRange = rangyHighlighter.converter.rangeToCharacterRange(rangyRange)\n    for (var i = 0; i < toRemoveHighlights.length; i++) {\n        var hl = toRemoveHighlights[i]\n        var charRange = hl.characterRange\n        if (charRange.start < toHighlightCharRange.start) {\n            toHighlightCharRange.start = charRange.start\n        }\n        if (charRange.end > toHighlightCharRange.end) {\n            toHighlightCharRange.end = charRange.end\n        }\n    }\n    return toHighlightCharRange\n}\n\nfunction getMarkerId(highlightId) {\n    return feelwithme.highlightIdToMarkId[highlightId]\n}\n\nfunction getHighlightId(markerId) {\n    return feelwithme.markIdTohighlightId[markerId]\n}\n/**\n * 注册 持久化ID(markerId) 与 rangy 的高亮ID (highlightId) 的双重映射关系\n * @param {*} markerId \n * @param {*} highlightId \n */\nfunction registerMarkerHighlightIdMapping(markerId, highlightId) {\n    feelwithme.highlightIdToMarkId[highlightId] = markerId\n    feelwithme.markIdTohighlightId[markerId] = highlightId\n}\n\n/**\n * 取消双向映射\n * @param {*} highlightId \n */\nfunction unregisterMarkerHighlightIdMapping(highlightId) {\n    var markerId = feelwithme.highlightIdToMarkId[highlightId]\n    delete feelwithme.highlightIdToMarkId[highlightId];\n    delete feelwithme.markIdTohighlightId[markerId]\n}\n\n/**\n * 注意: 这里的 removeHighlights 和  newhighlight 是有关联的,因为 新增的这个  newhighlight 导致 了 removeHighlights 被删除.\n * 如果不存在关联情况,需要单独调用 新增 和 删除\n * 变更 映射 的注册信息\n * @param {*} markId 标记的id\n * @param {*} newHighlight 新增的高亮\n * @param {*} removeHighlights 删除的高亮\n */\nfunction changeRegisterInfo(markId, newHighlight, removeHighlights) {\n\n    unregisterHighlight(removeHighlights)\n    registerHighlight(markId, newHighlight)\n}\n\nfunction unregisterHighlight(highlights) {\n    if (!highlights) {\n        return\n    }\n    for (var i = 0; i < highlights.length; i++) {\n        unregisterMarkerHighlightIdMapping(highlights[i].id)\n    }\n}\n\n/**\n * 注册 highlight 和 marker 的映射\n * @param {*} markId \n * @param {*} highlight \n * @returns \n */\nfunction registerHighlight(markId, highlight) {\n    if (!highlight) {\n        return\n    }\n    //实际上只有一个\n    registerMarkerHighlightIdMapping(markId, highlight.id)\n}\n\nfunction hasNoSelection(){\n    var sel = window.getSelection()\n    var selectText = getSelectionVisibleText(sel,false ) // 用户有权利选择多个 空格 作为标记\n    if(sel.isCollapsed || selectText.length == 0){ \n        return true\n    }\n    return false \n}\n\n\nreaderInput.delegateImpl.mark = function (markId, markClass) {\n    logger.debug("markId : ", markId, " markClass : ", markClass)\n    if(hasNoSelection() ){\n        // 当不存在 selection , 还在点击的时候 ,应该是在修改 markClass \n        changeMarkStyle(markClass)\n        return \n    }\n    var res = highlightSelection(markId, markClass , false )\n    readerOutput.onMarkCreated(res.markId ,res.markClass , res.removeMarkIds \n        , res.percentRate , res.location , res.text , res.isNoting)\n}\n\n/**\n * \n * @param {*} markId  如果是在 selection 的基础上新增 一个 mark , 那么这个 markId 就是新分配的 markId , 否则就是已经存在的 mark 的 markId\n * @param {*} markClass \n * @returns \n */\nreaderInput.delegateImpl.addNote = function(markId, markClass) {\n    /*\n        如果 selection 为空 ,那么说明要对 当前 Highlight 进行 add Note \n        否则 ,就是新建 Highlight  ,然后 addNote \n        返回的格式统一如下  : \n        {\n            markId : 如果是针对已经存在的 mark 加 note 的话 ,这个 markId 就要替换为已经存在的 mark 的 id \n            newMark : 新的 mark 信息 , 如果是新建 mark 的话 ,就包含这个信息 , 否则返回 nil  \n        }\n    */\n    if(hasNoSelection() ){\n        // 当不存在 selection , 说明不是新建 ,而是在已经存在的 mark 上添加 note 标记 \n        var hl = feelwithme.lastHighlight\n        if (!hl.hasNote){\n            hl.hasNote = true \n        }\n        return  { markId }\n    }else {\n        var res = highlightSelection(markId, markClass , true )\n        return { markId , newMark : res }\n    }\n}\n\n\nreaderInput.delegateImpl.markNote = function(hasNote) {\n    if (hasNoSelection()){// 因为 feelwithme.lastHighlight 保存的不是 当前的 ,而是最近的 \n        if (!!feelwithme.lastHighlight ){\n            feelwithme.lastHighlight.hasNote = hasNote \n        }\n    }\n}\n\nreaderInput.delegateImpl.loadMarks = function(marks){\n    logger.debug("load marks number : " , marks.length  , "marks : " , JSON.stringify(marks.map((x)=>x.percentRate)))\n\n    // 参考旧版本的 highlightMarkers 方法 \n    var lastPosistionMark = null\n    var maxY = 0\n\n    marks.forEach((mark) => {\n        if (getHighlightId(mark.markId) != null ){ // 避免重复高亮 . highlightId 可能从 0 开始 , !!0 == false , \n            logger.debug("mark has been highlight , skip ")\n            return \n        }\n        var yrange = findRangyRangeForLocation(mark.location)\n        if (yrange == null){\n            return \n        }\n        // 筛选出最末尾 的 mark  , 也就是 y 最大的 \n        var markY = yrange.nativeRange.getBoundingClientRect().y\n        if (markY > maxY) {\n            lastPosistionMark = mark\n            maxY = markY\n        }\n\n        var newHighlights = rangyHighlighter.highlightRanges(mark.style, [yrange])\n        newHighlights.forEach((hl) => {\n            // if (mark.noteNum > 0) {\n                hl.hasNote = (mark.noteFlag & 1) != 0 \n            // }\n        })\n\n        // \n        changeRegisterInfo(mark.markId,newHighlights[0],[])\n    })\n\n    if (lastPosistionMark != null){\n        feelwithme.tailMark = lastPosistionMark\n    }\n\n    if (marks.length >= feelwithme.loadMark.pageSize){\n        loadMarksIfNeed() // 继续加载  if need    \n    }else {\n        feelwithme.loadMark.done = true // 已经没有 marks 了 ,不再尝试加载  \n    }\n}\n\nreaderInput.delegateImpl.deleteMark = function(){\n    if ( feelwithme.lastHighlight != null ){\n        feelwithme.lastHighlight.unapply()\n    }\n}\n\n//----------------------------------------------- init --------------------------------------\nnew WhenUserInteract(onUserTouchNewSelection, onClickNonSelectionArea) // 如果不加 new , 那么 WhenUserInteract 里面的 this 就会指向 window\n\n\n\nlogger.debug("mark.js load success")\nfeelwithme.classAppliers = {}\nfeelwithme.lastHighlight = {} // 记录最近的 Highlight , 注意点 : 最新不一定是当前的 \n\n/*\n    涉及到 rangy 相关的方法 ,都写在这个 文件\n */\nfunction createXpathLocator( range ){\n    if (range.startContainer == document.body.parentElement ){ \n        range = changeRangeOfBody()\n    }\n    var commonBlockAncester = findCommonAncestorByPath(\'block\',[range.startContainer,range.endContainer])\n    // 这个作为 bookmark 的 container 进行保存\n    var commonBlockAncesterXpath = getSimpleXpath(commonBlockAncester)\n    var rangyRange = _lib_rangy_core_js__WEBPACK_IMPORTED_MODULE_1__.rangy.createRange();\n    rangyRange.setStartAndEnd(range.startContainer,range.startOffset, range.endContainer, range.endOffset)\n    var bookmark = serializeRangyRangeBookmark(rangyRange.getBookmark(commonBlockAncester),commonBlockAncesterXpath)\n    return bookmark\n}\n\nfunction changeRangeOfBody(){\n    var item = findFirstBlockElement(document.body)\n    var range = document.createRange()\n    range.selectNode(item)\n    return range\n}\nfunction findFirstBlockElement( rootElement ){\n    var childrentElements = rootElement.children\n    for ( var i = 0  ; i < childrentElements.length ; i ++ ){\n        var item = childrentElements[i]\n        if (isBlockNode(item)){\n            return item\n        }\n    }\n    return null \n}\n\n\nfunction serializeRangyRangeBookmark(rangeBookmark, containerXPath) {\n    /*\n        单个 range.getBookmark() 返回的样例:\n        {\n            containerNode : body\n            end : 85\n            start : 52\n        }\n        rangySelection 返回的格式:\n        {\n            "backward": false,\n            "rangeBookmarks": [\n                {\n                    "start": 12,\n                    "end": 15,\n                    "containerNode": {}\n                }\n            ]\n        }\n    */\n\n    /*\n     原来的格式:\n    \n     返回的格式:\n              {\n                 "backward": false,\n                 "containerXPath": /body[1]/div[2]\n                 "start": 12,\n                 "end": 15\n             }\n    理由:\n        bookmark 目前没有支持 多个 range 的理由\n     */\n    if (!rangeBookmark) {\n        return null\n    }\n    return {\n        containerXPath: containerXPath,\n        start: rangeBookmark.start,\n        end: rangeBookmark.end\n    }\n}\n\n// 放在这里的原因 :  引用了 createXpathLocator 函数\nreaderInput.delegateImpl.reportReadingProgress = function(scrollY){\n    logger.debug("reportReadingProgress : " , scrollY)\n    var range = findFirstRangeMatchScrollPosition(scrollY)\n    /*\n        fixme : 如果 range 是 body , 那么 怎么处理 "基于文本的定位" \n        createCompositLocatorForRange 时不把 range 放进 selection 里面 , 否则会影响到 add note 的操作\n            todo : 后期需要进行优化 ,用户点击 note 的时候 , js 把用户选择的 range 保存到 context 里面 ,这样用户确认保存的时候就可以直接使用这个 range ,而不是重新查找 .\n    */\n    var res = createCompositLocatorForRange(range ,null,false)\n    res.documentOffset = scrollY // 这一行可以去掉 ,也可以保留. 因为 range 对应的 y , 精准度上肯定不如 scrollY . 但是 由于 css 的变动 , 这个精准度估计也会失真  \n    readerOutput.onSaveProgress(res)\n}\n\nfunction createCompositLocatorForRange(range , renderTextOfRange , keepRangeInSelection = true , userCacheTextLocator = false){\n    if (!renderTextOfRange){\n        if (range.startContainer == document.body.parentElement ){\n            // 如果  range.startContainer 是 html , 说明这个 range 包含了 整个 body , 这时候 ,基于 文本的定位 失效\n            renderTextOfRange = "" \n        }else{\n            renderTextOfRange = range.toString()\n        }\n    }\n    var res = {}\n    res.version  = "composit/v1"\n    res.documentOffset = range.getBoundingClientRect().y\n    res.xpathLocation = createXpathLocator( range )\n    if (!!userCacheTextLocator && feelwithme.operationLocation.text != null){\n        res.textLocation = feelwithme.operationLocation.text\n    }else{\n        res.textLocation = createTextLocator(range , renderTextOfRange ,keepRangeInSelection)\n    }\n    return res \n}\n\n/*\n    重复调用 highlighter.highlightSelection(className) 可以替换任何你想替换的 className \n*/\nfunction onClickHighlight( elm){\n    var highlight = rangyHighlighter.getHighlightForElement(elm);\n    \n    // 记录当前的高亮对象\n    feelwithme.lastHighlight = highlight\n    feelwithme.thisHighlight = elm; // 暂时忘记这一行有什么用处 \n\n    var highlightId = highlight.id\n    var markerId = getMarkerId(highlightId)\n    var highlightRange = highlight.getRange().nativeRange // 特殊 case  : mark 分布在2个 block 里面, highlightRange.selectNode(elm)\n    var selectedText  = getVisibleTextOfRange(highlightRange)\n    var sentence =  findWholeSentence(highlightRange , selectedText , false )\n    var rect = elm.getBoundingClientRect();\n    // markId,  rect , selectedText , sentence , hasNote\n    onClickMark(markerId,rect , selectedText , sentence , highlight.hasNote) // 本来 mark.js 依赖 rangy-application.js 的 , 这下好了 ,循环引用了 , 唉\n}\n\nfunction createMarkerClassApplier(className){\n    var classApplier = _lib_rangy_core_js__WEBPACK_IMPORTED_MODULE_1__.rangy.createClassApplier(className, {\n        ignoreWhiteSpace: true,\n        // tagNames: ["span", "a"],\n        elementProperties: {\n            onclick: function(e) {\n                e.stopPropagation()\n                onClickHighlight(this);\n            }\n        }\n    })\n    feelwithme.classAppliers[className] =  classApplier\n    return classApplier\n}\n\n\n//----------------------------------------------- init --------------------------------------\nwhenDocumentTreeHasParsed(function () {\n    _lib_rangy_core_js__WEBPACK_IMPORTED_MODULE_1__.rangy.init();\n    window.rangyHighlighter = _lib_rangy_core_js__WEBPACK_IMPORTED_MODULE_1__.rangy.createHighlighter(); // 创建全局变量(window)\n\n    feelwithme.markClassList.forEach((x) => rangyHighlighter.addClassApplier(createMarkerClassApplier(x)))\n});\n\n\n\n//# sourceURL=webpack://appjs/./src/allApplication.js?')},"./src/app.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('__webpack_require__(/*! ./work.js */ "./src/work.js")\n\n//# sourceURL=webpack://appjs/./src/app.js?')},"./src/debug.js":()=>{eval('// logger.debug("going to load debug.js")\ndocument.title = feelwithme.init.docIndex + "-" + document.title || ""\n// logger.debug("debug scripts has loaded")\n// require(\'./business.js\')\n\n//# sourceURL=webpack://appjs/./src/debug.js?')},"./src/helpers.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DomHelper: () => (/* binding */ DomHelper),\n/* harmony export */   KeepRangeFlag: () => (/* binding */ KeepRangeFlag),\n/* harmony export */   NaturalTextHelper: () => (/* binding */ NaturalTextHelper),\n/* harmony export */   RangeHelper: () => (/* binding */ RangeHelper),\n/* harmony export */   SelectionHelper: () => (/* binding */ SelectionHelper),\n/* harmony export */   SelectionNaturalTextHelper: () => (/* binding */ SelectionNaturalTextHelper)\n/* harmony export */ });\n/*\n    出现 bug 的地方 : \n    保存的 range 不进行 copy ， 导致 selection 对象做了修改 . 参考 : cloneRange 说明 \n*/\nclass KeepRangeFlag {\n    // 不改动 操作以后 的 range\n    static KEEP = 0\n    // 保留 origin\n    static ORIGIN = 1\n    // 保留 传入的 range \n    static TARGET = 2\n    // 删除所有的 range  \n    static EMPTY = 3\n}\n\nclass SelectionHelper {\n    static shared = new SelectionHelper();\n\n    /**\n     * 操作 selection 的通用方法 \n     * \n     * 一般情况下，我们需要 {使用,不使用} 我们保存的 range , {更新,不更新 }  我们的 range  , 保存 哪个 range 在 seletion 中 \n     * \n     * 知识点 : \n     *      selection 移动 以后， selection 内部的 rangeA 会发生变化(不是值的变化，而是一个全新的对象)\n     * @param {Selection} sel \n     * @param {Range} curRange 为 null 则默认取 selection 中的 range\n     * @param {String} textOfCurRange 可以为 null 则默认取 selection 中的 toString\n     * @param {Number} keepRangeFlag 必须有值\n     * @param {Function } operator 必须有值  \n     */\n    operate = (sel , curRange , textOfCurRange, flag , operator ) => {\n        var sel = sel || window.getSelection()  \n        // 必须是 clone  ， 否则 selection 对象可能会修改 range \n        var originRange = sel.rangeCount > 0 ? sel.getRangeAt(0).cloneRange() : null ; \n\n        var finalCurRange = curRange || originRange  \n        var finalTextOfCurRange = textOfCurRange || sel.toString()\n\n        if (curRange != null ){\n            if (sel.rangeCount > 0){\n                sel.removeAllRanges()\n            }\n            sel.addRange(curRange)\n        }\n        var operationResult = operator(sel,finalCurRange,finalTextOfCurRange)\n        /*\n            记录操作完成以后在 selection 中 range 的最新值 \n        */\n        var latestRange = null \n        if (sel.rangeCount > 0){\n            latestRange = sel.getRangeAt(0)\n        }\n\n        /*\n            根据 flag 决定 是否需要变更 selection 中的 range\n        */\n        if (flag == KeepRangeFlag.EMPTY){\n            sel.removeAllRanges()\n        }else if(flag == KeepRangeFlag.TARGET && curRange != null){\n            sel.removeAllRanges()\n            sel.addRange(curRange)\n        }else if(flag == KeepRangeFlag.ORIGIN && originRange != null){\n            sel.removeAllRanges()\n            sel.addRange(originRange)\n        }\n\n        return {range : latestRange  , result : operationResult}\n    }\n\n    simpleOperate = (sel , curRange , textOfCurRange, flag , operator ) => {\n        // 不返回 res.result , 而是只返回 range\n        var res = this.operate(sel , curRange , textOfCurRange, flag , operator)\n        return res.range \n    }\n}\n\n/**\n * 自然语言服务工具\n */\nclass SelectionNaturalTextHelper {\n    static shared = new SelectionNaturalTextHelper();\n\n\n    /**\n     * 向前移动 selection \n     * \n     * 为什么不直接使用 Selection.modify 的方法去移动 ，而是如此大费周章 ?\n     *      因为 { chrome , safari } 均存在 bug , 比如  sel.modify("extend", "forward", "sentence")  在 stackoverflow 的站点会陷入死循环\n     *          具体的现象有 : 到达某个 block 的末尾时 ， forward 竟然会出现倒退回去的 情况 。 然后在此 modify 的时候 ，回到末尾 。 这样反复就陷入死循环了 。 \n     *          复现\n     *              例子 :  https://stackoverflow.com/questions/13275013/save-current-directory-in-variable-using-bash  \n     *                  选中问题的标题的一部分 ，一直执行 sel.modify("extend", "forward", "sentence") , sel.collapseToEnd() ， 就会发现卡在某个 地方不动了 \n     * \n     * 如何保证一定向前移动 ? 就是 保证 selection 在 移动前 和 移动后 的 range 是移动的 。\n     *      判断前移有参考标准有 :\n     *          从 range 所处的  rectange 渲染位置判断 ，实践证明不准确 . 比如 存在 float 的情况 \n     *          按照  document tree 的顺序  。 目前是按照这个 标准 ，挺准确的 。\n     * \n     * @param {Selection} sel \n     * @param {*} moveFunc \n     * @param {*} afterSucessFunc \n     * @returns 返回 boolean 表示 是否成功向前移动了  \n     */\n    moveSelection = (sel, moveFunc) => {\n        var aRange = sel.getRangeAt(0).cloneRange()\n        moveFunc(sel)\n        var bRange = sel.getRangeAt(0)\n        /*\n            整体思路 : \n                尝试移动 ， 移动成功后就返回  \n         */\n\n        if (RangeHelper.shared.isForward(aRange, bRange)) {\n            return true\n        }\n\n        /*\n            移动不成功 ， 可能的原因 :\n                - 移动到 document 的 结尾了 \n                    -- 如果后续没有 新的 textNode 了 ，在此背景等价于到达了 结尾\n                - 有 bug 导致回退 ( chrome , safari 浏览器 均有 这个 bug )\n         */\n\n        // 移动不成功，我们需要把旧的 range 放回来 \n        sel.removeAllRanges()\n        sel.addRange(aRange)\n\n        function getExcludeBeginNode(endContainer, endOffset) {\n            if (endContainer.nodeType == 3) {\n                return endContainer\n            }\n            var endIdx = endOffset - 1 // 因为 end 是没有被包含到 selection 中进行加计算的 \n            if (endIdx < endContainer.childNodes.length) {\n                return endContainer.childNodes[endIdx]\n            }\n            return endContainer\n        }\n\n        var execludeBeginNode = getExcludeBeginNode(aRange.endContainer, aRange.endOffset)\n\n\n        var beginPredict = function (node) {\n            return node != execludeBeginNode\n        }\n        var filterPredict = function (node) {\n            return true\n        }\n        filterPredict = createVisibleNodeFilterPredict(filterPredict)\n\n        var ok = false\n        var handleFunc = function (node) {\n            ok = node.nodeType == 3 && node.textContent.trim().length > 0\n            if (ok) {\n                console.log("new reach node text : ", node.textContent.trim())\n                sel.setBaseAndExtent(node, 0, node, 1)\n                moveFunc(sel)\n                ok = RangeHelper.shared.isForward(aRange, sel.getRangeAt(0))\n                console.log("after move , forward : ", ok, "  , origin : ", sel.getRangeAt(0).getBoundingClientRect())\n            }\n            return ok\n        }\n        DomHelper.shared.travelDocumentNode(execludeBeginNode, true, beginPredict, filterPredict, handleFunc)\n        console.log("has done iteration of whole document tree ")\n        return ok\n    }\n\n    /**\n     * 移动一个完整的 granularity \n     *      如果用户选择了中间的一部分，我们需要分别 {向前 , 向后移动 } \n     * todo : 为了防止移动不成功 ， 后续可以把 moveSelection 修改为 支持 forward ， backward 2种移动方式   \n     * @param {Selection} sel \n     * @param {String } locatorText \n     * @param {String } granularity \n     * @param {(String , Number) => void} startBoundaryPredict  传入的 index 是 exclusive \n     * @param {(String , Number) => void} endBoundaryPredic 传入的 index 是 inclusive \n     * @returns   完整的 granularity 对应的 text  + locatorText 在 granularity 中的偏移量\n     */\n    expandWholeGranularity = (sel, locatorText, granularity , startBoundaryPredict, endBoundaryPredic) => {\n        var ran = sel.getRangeAt(0).cloneRange()\n        var beginIndex = 0\n        sel.modify("extend", "backward", granularity);\n        var newText = sel.toString()\n        var isAlreadyAtStart = startBoundaryPredict(newText, newText.length - locatorText.length )\n        if (isAlreadyAtStart) {\n            // 如果已经在完整 part 的开始位置了 ， 就没有必要移动到更后面\n            sel.removeAllRanges()\n            sel.addRange(ran) // 回到原来的移动位置\n        }else{\n            // 更新 beginIndex \n            beginIndex += newText.length - locatorText.length\n            locatorText = newText\n        }\n        /*\n            必须 ran 要重新获取 比如 : 我们 backward 以后 , anchorNode , focusNode 没有改变.\n            这时候 ，如果我们 forward ， 就会导致 selection 从 anchor node 开始 expand\n                而我们的预期是 : 如果我们采用了 backward 的 action  ，那么 新的 anchorNode 应该改为 新的  focusNode \n        */\n        ran = sel.getRangeAt(0)\n        if (!endBoundaryPredic(locatorText , locatorText.length - 1)) {\n            sel.setBaseAndExtent(ran.startContainer, ran.startOffset, ran.endContainer, ran.endOffset)\n            sel.modify("extend", "forward", granularity);\n            locatorText = sel.toString()\n        }\n        return { locatorText, beginIndex } \n    }\n\n\n    selectCurrentWord = () => {\n        var self = this \n        var granularity = "word"\n        var startBoundaryPredict = function(text , endIndex){\n            endIndex = endIndex - 1\n            return endIndex < text.length && NaturalTextHelper.shared.isWhiteStr(text[endIndex])\n        }\n        var endBoundaryPredic = function(text , startIndex){\n            return startIndex < text.length && NaturalTextHelper.shared.isWhiteStr(text[startIndex])\n        }\n        var expandToPart = function (sel) {\n            var originText = sel.toString()\n            return self.expandWholeGranularity(sel,originText, granularity ,startBoundaryPredict,endBoundaryPredic)\n        }\n        var res = SelectionHelper.shared.operate(null, null, null, KeepRangeFlag.ORIGIN, expandToPart)\n        return res.result.locatorText\n    }\n\n    /**\n     * 扩展当前的 sel 到一个完整的句子  \n     * @param {Selection} sel \n     * @param {String} locatorText \n     * @returns 完整的句子 对应的 text  + locatorText 在句子中的偏移量\n     */\n    expandToWholeSentence = (sel,locatorText) => {\n        var self = this \n        var granularity = "sentence"\n        var startBoundaryPredict = NaturalTextHelper.shared.isAtStartOfSentence\n        var endBoundaryPredic = NaturalTextHelper.shared.isAtEndOfSentence\n        var expandToPart = function (sel) {\n            return self.expandWholeGranularity(sel,locatorText, granularity ,startBoundaryPredict,endBoundaryPredic)\n        }\n        var res = SelectionHelper.shared.operate(sel, null, null, KeepRangeFlag.KEEP, expandToPart)\n        return res.result\n    }\n\n    selectCurrentSentence = (granularity) => {\n        var sel = window.getSelection()\n        var originalRange = sel.rangeCount > 0 ? sel.getRangeAt(0).cloneRange() : null\n        if (originalRange == null){\n            return null\n        }\n        var text = sel.toString()\n        var res = this.expandToWholeSentence(sel,text )\n        sel.removeAllRanges()\n        sel.addRange(originalRange);\n        return res.locatorText\n    }\n\n    selectCurrentParagraph = ()=> {\n        var self = this \n        var granularity = "paragraphboundary"\n        var startBoundaryPredict = function(text , endIndex){\n            return endIndex < text.length && NaturalTextHelper.shared.isWhiteStr(text[endIndex])\n        }\n        var endBoundaryPredic = function(text , startIndex){\n            return startIndex < text.length && NaturalTextHelper.shared.isWhiteStr(text[startIndex])\n        }\n        var expandToPart = function (sel) {\n            var originText = sel.toString()\n            return self.expandWholeGranularity(sel,originText, granularity ,startBoundaryPredict,endBoundaryPredic)\n        }\n        var res = SelectionHelper.shared.operate(null, null, null, KeepRangeFlag.ORIGIN, expandToPart)\n        return res.result.locatorText\n    }\n\n}\n\nclass RangeHelper {\n    static shared = new RangeHelper();\n    /**\n     * 判断 b 是否相对于 a 在 dom tree 的位置中 向前移动了 \n     * 怎样算是向前移动 :\n     *      b 的尾巴 比 a 的尾巴更靠近文档结尾\n     * 注意点 :\n     *      如果 a b 存在 继承关系(b 是 a 的后代 或者 a 是 b 的 后代 ), 那么我们认为没有移动  \n     * @param {Range} a \n     * @param {Range} b \n     */\n    isForward = (a, b) => {\n        if (a.endContainer == b.endContainer) {\n            return a.endOffset < b.endOffset\n        }\n        var aNode = a.endContainer\n        var bNode = b.endContainer\n        var commonAncester = findCommonAncestorByPath(null, [aNode, bNode])\n        if (commonAncester == b || commonAncester == a) {\n            // 存在 继承关系  \n            return false\n        }\n        var res = DomHelper.shared.findIndexInContainer(commonAncester, aNode) < DomHelper.shared.findIndexInContainer(commonAncester, bNode)\n        return res\n    }\n\n}\nclass NaturalTextHelper {\n    static shared = new NaturalTextHelper();    \n\n    isWhiteStr = (str) => {\n        return [" ", "\\t", "\\n", "\\r"].indexOf(str) != -1;\n    }\n\n    isSentenceBreakChar = (char) => {\n        return [\n            // english\n            ".", ";", "?", "!", "…" , "..." , "\\n", "\\r", // "..." 需要额外处理 \n            // chinese\n            , "。", "！", "？", "；"].indexOf(char) != -1;\n    }\n\n    /**\n     * 判断是否是 text break 的地方 \n     * @param {String } text \n     * @param {number} beginIndex \n     * @param {number} endIndex \n     * @param {number} delta \n     * @param {(String) => boolean } cheker \n     * @returns \n     */\n    textBreakCheck = (text , beginIndex , endIndex , delta , cheker) => {\n        for (var i = beginIndex; i != endIndex ; i += delta){\n            var ch = text[i]\n            if (cheker(ch)){\n                return true \n            }\n            if (this.isWhiteStr(ch)){\n                continue\n            }\n            return false \n        }\n    }\n\n    /**\n     * \n     * @param {String } text \n     * @param {number} beginIndex \n     * @param {number} endIndex \n     * @param {number} delta \n     * @returns \n     */\n    sentenceBreakCheck = (text , beginIndex , endIndex , delta)=> {\n        for (var i = beginIndex; i != endIndex ; i += delta){\n            var ch = text[i]\n            if (this.isSentenceBreakChar(ch)){\n                return true \n            }\n            if (this.isWhiteStr(ch)){\n                continue\n            }\n            return false \n        }\n    }\n\n    /**\n     * 判断 idx 所处的位置是否算是 一个 sentence 的开始位置  \n     * 如果从 idx 开始逆序 ，一直都是 空白符 ，一直到首个 非空白符是 sentenceBreakChar , 我们就认为是 处于 sentence 的开始位置  \n     * @param {String } text \n     * @param {Number } endIndex exclusive  \n     * @returns \n     */\n    isAtStartOfSentence = (text, endIndex) => {\n        return this.sentenceBreakCheck(text , endIndex - 1 , -1 , - 1)\n    }\n\n    isAtEndOfSentence = (text, beginIndex)=> {\n        return this.sentenceBreakCheck(text , beginIndex  , text.length , 1)\n    }\n\n    isAtBeginOfParagrah = (text, endIndex) => {\n        var check = (x) => x == \'\\n\'\n        return this.textBreakCheck(text,endIndex - 1 , -1 , -1 , check)\n    }\n\n    isAtEndOfParagrah = (text, beginIndex) => {\n        var check = (x) => x == \'\\n\'\n        return this.textBreakCheck(text,beginIndex, text.length , 1 , check)\n    }\n}\n\nclass DomHelper {\n    static shared = new DomHelper();\n\n    /**\n     * 选择最深的 后代 node  \n     * @param {Node} node \n     * @param {boolean} isFirst  true : 选择 first child ， false : 选择 last child \n     * @returns \n     */\n    deepestDescedantNode = (node, isFirst) => {\n        var childNodes = node.childNodes\n        if (childNodes == null || childNodes.length == 0) {\n            return node\n        } else {\n            node = isFirst ? childNodes[0] : childNodes[childNodes.length - 1]\n            return this.deepestDescedantNode(node, isFirst)\n        }\n    }\n\n\n    /**\n     * 获取 left most & deep most node \n     * @param {Node} node \n     * @returns \n     */\n    deepestFisrtDescedantNode = (node) => {\n        return this.deepestDescedantNode(node, true)\n    }\n\n    /**\n     * 遍历 node \n     * @param {Node} node \n     * @param {boolean} forward \n     * @param {*} beginPredict \n     * @param {*} filterPredict \n     * @param {*} handleFunc \n     */\n    travelDocumentNode = (node, forward, beginPredict, filterPredict, handleFunc) => {\n        var hasBegin = false\n        /*\n            因为在 doTravelDocumentNode 中，我们会重复调用 dfsNode 而不是只调用一次 ，所以可能存在 beginPredict 的值重新计算的 问题 。\n        */\n        var beginPredictWrapper = function (node) {\n            if (hasBegin) {\n                return hasBegin\n            } else {\n                return beginPredict(node)\n            }\n        }\n        this.doTravelDocumentNode(node, forward, beginPredictWrapper, filterPredict, handleFunc)\n    }\n\n    /**\n     * 按照 DOM tree 进行 顺序 或者 逆序 的 遍历\n     * \n     * 因为 我们是从 某个 node 开始的 ， 所以只能选择 后续遍历 \n     * @param {Node} node \n     * @param {boolean} forward \n     * @param {*} filterPredict \n     * @param {*} handleFunc \n     */\n    doTravelDocumentNode = (node, forward, beginPredict, filterPredict, handleFunc) => {\n        /*\n            思路 :\n                document 的 node 会形成 tree \n                按照递归的定义 ， \n                    forward 就意味着 : 遍历node  和 node 的后面 兄弟 ， 然后 递归 node 的 parent 的 后面兄弟\n                    forward 就意味着 : 遍历node  和 node 的前面续 兄弟 ， 然后 递归 node 的 parent 的 前面兄弟\n        */\n        var preOrder = false\n        var stop = this.dfsNode(node, forward, preOrder, beginPredict, filterPredict, handleFunc)\n        if (stop) {\n            return\n        }\n        if (forward) {\n            while (node.nextSibling) {\n                node = node.nextSibling\n                stop = this.dfsNode(node, forward, preOrder, beginPredict, filterPredict, handleFunc)\n                if (stop) {\n                    return\n                }\n            }\n        } else {\n            while (node.previousSibling) {\n                node = node.previousSibling\n                stop = this.dfsNode(node, forward, preOrder, beginPredict, filterPredict, handleFunc)\n                if (stop) {\n                    return\n                }\n            }\n        }\n\n        /*\n            向上访问 ( postOrder 遍历 )\n            如果 forward == true \n                当 node.nextSiling == null 时 ， 需要继续向上更新 parentNode\n            如果 forward == false \n                当 node.previousSiling == null 时 ， 需要继续向上更新 parentNode\n         */\n        while ((forward ? !node.nextSibling : !node.previousSibling)) {\n            node = node.parentNode\n            if (node == null) {\n                return\n            }\n            stop = handleFunc(node)\n            if (stop) {\n                return\n            }\n        }\n        node = forward ? node.nextSibling : node.previousSibling\n        this.doTravelDocumentNode(node, forward, beginPredict, filterPredict, handleFunc)\n    }\n\n    /**\n     * 深度优先 遍历 body dom  , 参考自 rangy 框架的 getbookmark 还是 findbookmark 的实现 ,基于 stack ,避免 调用栈过长\n     * beginPredict -> filterPredict -> handleFunc 串联起来  ,中间断了的话  handleFunc 就不会执行\n     * beginPredict 仅仅用于测试是否开始 handle node , 一旦开始就不再 调用 beginPredict\n     * filterPredict 则贯穿遍历 dom tree 的整个生命周期 , filterPredict 的作用 : 可以快速过滤一个大的 node ,而不需要递归其 后代 node ,减少不必要的遍历 .\n     *\n     * @param {Node} rootNode 以哪个节点为根节点 , 为 nil 则使用 body 作为 node\n     * @param {boolean} forward 子节点是 顺序遍历还是倒序遍历(从调用者角度)\n     * @param {boolean} preOrder 是否是前序遍历 , 不是前序的话就是后序 , 暂时不支持 中序遍历\n     * @param {boolean} beginPredict 在遍历 body 的过程中, 不是什么元素都会被 handleFunc 处理,而是遍历到特定 的 node 的时候 才开始考虑是否处理 . \n     * @param {boolean} filterPredict filterPredict 返回 true 则继续 递归 这个 node ,否则跳过 递归  这个 node ( beginPredict 为 false 时也会被调用)\n     *          主要的用途是用于快速跳过某些没有必要探索的 node\n     * @param {boolean} handleFunc 返回 true 代表 结束 遍历\n     *      业务处理的node  ，只有 beignPredict == true && filterPredict == true 才会被 handleFunc 处理  \n     */\n    dfsNode = (rootNode, forward, preOrder, beginPredict, filterPredict, handleFunc) => {\n        var containerNode = rootNode || document.body // 默认从 body 开始处理\n        var nodeStack = [containerNode], node, stop = false;\n        var i, childNodes, len;\n        var shouldBegin = false\n\n        while (!stop && (node = nodeStack.pop())) {\n            var shouldBegin = shouldBegin || beginPredict(node)\n            var shouldFilter = filterPredict(node)\n\n            /*\n             * preOrder 控制 parent 的访问究竟是在 children 前 还是 后 , 也就是 要么前序遍历 \\ 要么后序遍历\n             * beginPredict 是依赖于遍历顺序的\n             */\n            if (preOrder && shouldBegin && shouldFilter) {\n                stop = handleFunc(node)\n            }\n            if (stop) {\n                break\n            }\n\n            if (shouldFilter) { // filterPredict 返回 false 则不再 遍历这个 node 及其 后代\n                childNodes = node.childNodes;\n                i = childNodes.length;\n                if (forward) {\n                    // left --\x3e right 的顺序遍历 , stack 倒过来是因为我们处理的是 pop 出来的元素 , 所以 stack 倒过来的效果就是 caller 能够 正序(left->right) 访问 child\n                    while (i--) {\n                        nodeStack.push(childNodes[i]);\n                    }\n                } else {\n                    len = node.childNodes.length;\n                    // left <-- right 的顺序遍历\n                    for (var j = 0; j < len; j++) {\n                        nodeStack.push(childNodes[j]);\n                    }\n                }\n            }\n\n            if (!preOrder && shouldBegin && shouldFilter) {\n                stop = handleFunc(node)\n            }\n        }\n        return stop\n    }\n\n    /**\n     * 找到 descendantNode 在 containerNode 中的 index 索引\n     *   descendantNode 可能不是 containerNode 的 child ， 所以必须向上找到 一个是 container 的child 的 祖先\n     * @param {Node} containerNode \n     * @param {Node} descendantNode \n     */\n    findIndexInContainer = (containerNode, descendantNode) => {\n        if (containerNode == null || containerNode.firstChild == null) {\n            return -1\n        }\n        while (descendantNode != null && descendantNode.parentNode != containerNode) {\n            descendantNode = descendantNode.parentNode\n        }\n        if (descendantNode == null) {\n            return -1\n        }\n        for (var child = containerNode.firstChild, i = 0; child !== null; child = child.nextSibling, i++) {\n            if (child == descendantNode) {\n                return i\n            }\n        }\n        return -1\n    }\n}\n\n\n// export { KeepRangeFlag , SelectionHelper , SelectionNaturalTextHelper , RangeHelper , NaturalTextHelper , DomHelper};\n\n\n//# sourceURL=webpack://appjs/./src/helpers.js?')},"./src/lib/rangy-classapplier.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rangy_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rangy-core.js */ "./src/lib/rangy-core.js");\n/**\n * Class Applier module for Rangy.\n * Adds, removes and toggles classes on Ranges and Selections\n *\n * Part of Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Depends on Rangy core.\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\n\n\n\nvar exps = (function(rangy) {\n    rangy.createModule("ClassApplier", ["WrappedSelection"], function(api, module) {\n        var dom = api.dom;\n        var DomPosition = dom.DomPosition;\n        var contains = dom.arrayContains;\n        var util = api.util;\n        var forEach = util.forEach;\n\n\n        var defaultTagName = "span";\n        var createElementNSSupported = util.isHostMethod(document, "createElementNS");\n\n        function each(obj, func) {\n            for (var i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    if (func(i, obj[i]) === false) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        function trim(str) {\n            return str.replace(/^\\s\\s*/, "").replace(/\\s\\s*$/, "");\n        }\n\n        function classNameContainsClass(fullClassName, className) {\n            return !!fullClassName && new RegExp("(?:^|\\\\s)" + className + "(?:\\\\s|$)").test(fullClassName);\n        }\n\n        // Inefficient, inelegant nonsense for IE\'s svg element, which has no classList and non-HTML className implementation\n        function hasClass(el, className) {\n            if (typeof el.classList == "object") {\n                return el.classList.contains(className);\n            } else {\n                var classNameSupported = (typeof el.className == "string");\n                var elClass = classNameSupported ? el.className : el.getAttribute("class");\n                return classNameContainsClass(elClass, className);\n            }\n        }\n\n        function addClass(el, className) {\n            if (typeof el.classList == "object") {\n                el.classList.add(className);\n            } else {\n                var classNameSupported = (typeof el.className == "string");\n                var elClass = classNameSupported ? el.className : el.getAttribute("class");\n                if (elClass) {\n                    if (!classNameContainsClass(elClass, className)) {\n                        elClass += " " + className;\n                    }\n                } else {\n                    elClass = className;\n                }\n                if (classNameSupported) {\n                    el.className = elClass;\n                } else {\n                    el.setAttribute("class", elClass);\n                }\n            }\n        }\n\n        var removeClass = (function() {\n            function replacer(matched, whiteSpaceBefore, whiteSpaceAfter) {\n                return (whiteSpaceBefore && whiteSpaceAfter) ? " " : "";\n            }\n\n            return function(el, className) {\n                if (typeof el.classList == "object") {\n                    el.classList.remove(className);\n                } else {\n                    var classNameSupported = (typeof el.className == "string");\n                    var elClass = classNameSupported ? el.className : el.getAttribute("class");\n                    elClass = elClass.replace(new RegExp("(^|\\\\s)" + className + "(\\\\s|$)"), replacer);\n                    if (classNameSupported) {\n                        el.className = elClass;\n                    } else {\n                        el.setAttribute("class", elClass);\n                    }\n                }\n            };\n        })();\n\n        function getClass(el) {\n            var classNameSupported = (typeof el.className == "string");\n            return classNameSupported ? el.className : el.getAttribute("class");\n        }\n\n        function sortClassName(className) {\n            return className && className.split(/\\s+/).sort().join(" ");\n        }\n\n        function getSortedClassName(el) {\n            return sortClassName( getClass(el) );\n        }\n\n        function haveSameClasses(el1, el2) {\n            return getSortedClassName(el1) == getSortedClassName(el2);\n        }\n\n        function hasAllClasses(el, className) {\n            var classes = className.split(/\\s+/);\n            for (var i = 0, len = classes.length; i < len; ++i) {\n                if (!hasClass(el, trim(classes[i]))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function canTextBeStyled(textNode) {\n            var parent = textNode.parentNode;\n            return (parent && parent.nodeType == 1 && !/^(textarea|style|script|select|iframe)$/i.test(parent.nodeName));\n        }\n\n        function movePosition(position, oldParent, oldIndex, newParent, newIndex) {\n            var posNode = position.node, posOffset = position.offset;\n            var newNode = posNode, newOffset = posOffset;\n\n            if (posNode == newParent && posOffset > newIndex) {\n                ++newOffset;\n            }\n\n            if (posNode == oldParent && (posOffset == oldIndex  || posOffset == oldIndex + 1)) {\n                newNode = newParent;\n                newOffset += newIndex - oldIndex;\n            }\n\n            if (posNode == oldParent && posOffset > oldIndex + 1) {\n                --newOffset;\n            }\n\n            position.node = newNode;\n            position.offset = newOffset;\n        }\n\n        function movePositionWhenRemovingNode(position, parentNode, index) {\n            if (position.node == parentNode && position.offset > index) {\n                --position.offset;\n            }\n        }\n\n        function movePreservingPositions(node, newParent, newIndex, positionsToPreserve) {\n            // For convenience, allow newIndex to be -1 to mean "insert at the end".\n            if (newIndex == -1) {\n                newIndex = newParent.childNodes.length;\n            }\n\n            var oldParent = node.parentNode;\n            var oldIndex = dom.getNodeIndex(node);\n\n            forEach(positionsToPreserve, function(position) {\n                movePosition(position, oldParent, oldIndex, newParent, newIndex);\n            });\n\n            // Now actually move the node.\n            if (newParent.childNodes.length == newIndex) {\n                newParent.appendChild(node);\n            } else {\n                newParent.insertBefore(node, newParent.childNodes[newIndex]);\n            }\n        }\n\n        function removePreservingPositions(node, positionsToPreserve) {\n\n            var oldParent = node.parentNode;\n            var oldIndex = dom.getNodeIndex(node);\n\n            forEach(positionsToPreserve, function(position) {\n                movePositionWhenRemovingNode(position, oldParent, oldIndex);\n            });\n\n            dom.removeNode(node);\n        }\n\n        function moveChildrenPreservingPositions(node, newParent, newIndex, removeNode, positionsToPreserve) {\n            var child, children = [];\n            while ( (child = node.firstChild) ) {\n                movePreservingPositions(child, newParent, newIndex++, positionsToPreserve);\n                children.push(child);\n            }\n            if (removeNode) {\n                removePreservingPositions(node, positionsToPreserve);\n            }\n            return children;\n        }\n\n        function replaceWithOwnChildrenPreservingPositions(element, positionsToPreserve) {\n            return moveChildrenPreservingPositions(element, element.parentNode, dom.getNodeIndex(element), true, positionsToPreserve);\n        }\n\n        function rangeSelectsAnyText(range, textNode) {\n            var textNodeRange = range.cloneRange();\n            textNodeRange.selectNodeContents(textNode);\n\n            var intersectionRange = textNodeRange.intersection(range);\n            var text = intersectionRange ? intersectionRange.toString() : "";\n\n            return text != "";\n        }\n\n        function getEffectiveTextNodes(range) {\n            var nodes = range.getNodes([3]);\n\n            // Optimization as per issue 145\n\n            // Remove non-intersecting text nodes from the start of the range\n            var start = 0, node;\n            while ( (node = nodes[start]) && !rangeSelectsAnyText(range, node) ) {\n                ++start;\n            }\n\n            // Remove non-intersecting text nodes from the start of the range\n            var end = nodes.length - 1;\n            while ( (node = nodes[end]) && !rangeSelectsAnyText(range, node) ) {\n                --end;\n            }\n\n            return nodes.slice(start, end + 1);\n        }\n\n        function elementsHaveSameNonClassAttributes(el1, el2) {\n            if (el1.attributes.length != el2.attributes.length) return false;\n            for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {\n                attr1 = el1.attributes[i];\n                name = attr1.name;\n                if (name != "class") {\n                    attr2 = el2.attributes.getNamedItem(name);\n                    if ( (attr1 === null) != (attr2 === null) ) return false;\n                    if (attr1.specified != attr2.specified) return false;\n                    if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) return false;\n                }\n            }\n            return true;\n        }\n\n        function elementHasNonClassAttributes(el, exceptions) {\n            for (var i = 0, len = el.attributes.length, attrName; i < len; ++i) {\n                attrName = el.attributes[i].name;\n                if ( !(exceptions && contains(exceptions, attrName)) && el.attributes[i].specified && attrName != "class") {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        var getComputedStyleProperty = dom.getComputedStyleProperty;\n        var isEditableElement = (function() {\n            var testEl = document.createElement("div");\n            return typeof testEl.isContentEditable == "boolean" ?\n                function (node) {\n                    return node && node.nodeType == 1 && node.isContentEditable;\n                } :\n                function (node) {\n                    if (!node || node.nodeType != 1 || node.contentEditable == "false") {\n                        return false;\n                    }\n                    return node.contentEditable == "true" || isEditableElement(node.parentNode);\n                };\n        })();\n\n        function isEditingHost(node) {\n            var parent;\n            return node && node.nodeType == 1 &&\n                (( (parent = node.parentNode) && parent.nodeType == 9 && parent.designMode == "on") ||\n                (isEditableElement(node) && !isEditableElement(node.parentNode)));\n        }\n\n        function isEditable(node) {\n            return (isEditableElement(node) || (node.nodeType != 1 && isEditableElement(node.parentNode))) && !isEditingHost(node);\n        }\n\n        var inlineDisplayRegex = /^inline(-block|-table)?$/i;\n\n        function isNonInlineElement(node) {\n            return node && node.nodeType == 1 && !inlineDisplayRegex.test(getComputedStyleProperty(node, "display"));\n        }\n\n        // White space characters as defined by HTML 4 (http://www.w3.org/TR/html401/struct/text.html)\n        var htmlNonWhiteSpaceRegex = /[^\\r\\n\\t\\f \\u200B]/;\n\n        function isUnrenderedWhiteSpaceNode(node) {\n            if (node.data.length == 0) {\n                return true;\n            }\n            if (htmlNonWhiteSpaceRegex.test(node.data)) {\n                return false;\n            }\n            var cssWhiteSpace = getComputedStyleProperty(node.parentNode, "whiteSpace");\n            switch (cssWhiteSpace) {\n                case "pre":\n                case "pre-wrap":\n                case "-moz-pre-wrap":\n                    return false;\n                case "pre-line":\n                    if (/[\\r\\n]/.test(node.data)) {\n                        return false;\n                    }\n            }\n\n            // We now have a whitespace-only text node that may be rendered depending on its context. If it is adjacent to a\n            // non-inline element, it will not be rendered. This seems to be a good enough definition.\n            return isNonInlineElement(node.previousSibling) || isNonInlineElement(node.nextSibling);\n        }\n\n        function getRangeBoundaries(ranges) {\n            var positions = [], i, range;\n            for (i = 0; range = ranges[i++]; ) {\n                positions.push(\n                    new DomPosition(range.startContainer, range.startOffset),\n                    new DomPosition(range.endContainer, range.endOffset)\n                );\n            }\n            return positions;\n        }\n\n        function updateRangesFromBoundaries(ranges, positions) {\n            for (var i = 0, range, start, end, len = ranges.length; i < len; ++i) {\n                range = ranges[i];\n                start = positions[i * 2];\n                end = positions[i * 2 + 1];\n                range.setStartAndEnd(start.node, start.offset, end.node, end.offset);\n            }\n        }\n\n        function isSplitPoint(node, offset) {\n            if (dom.isCharacterDataNode(node)) {\n                if (offset == 0) {\n                    return !!node.previousSibling;\n                } else if (offset == node.length) {\n                    return !!node.nextSibling;\n                } else {\n                    return true;\n                }\n            }\n\n            return offset > 0 && offset < node.childNodes.length;\n        }\n\n        function splitNodeAt(node, descendantNode, descendantOffset, positionsToPreserve) {\n            var newNode, parentNode;\n            var splitAtStart = (descendantOffset == 0);\n\n            if (dom.isAncestorOf(descendantNode, node)) {\n                return node;\n            }\n\n            if (dom.isCharacterDataNode(descendantNode)) {\n                var descendantIndex = dom.getNodeIndex(descendantNode);\n                if (descendantOffset == 0) {\n                    descendantOffset = descendantIndex;\n                } else if (descendantOffset == descendantNode.length) {\n                    descendantOffset = descendantIndex + 1;\n                } else {\n                    throw module.createError("splitNodeAt() should not be called with offset in the middle of a data node (" +\n                        descendantOffset + " in " + descendantNode.data);\n                }\n                descendantNode = descendantNode.parentNode;\n            }\n\n            if (isSplitPoint(descendantNode, descendantOffset)) {\n                // descendantNode is now guaranteed not to be a text or other character node\n                newNode = descendantNode.cloneNode(false);\n                parentNode = descendantNode.parentNode;\n                if (newNode.id) {\n                    newNode.removeAttribute("id");\n                }\n                var child, newChildIndex = 0;\n\n                while ( (child = descendantNode.childNodes[descendantOffset]) ) {\n                    movePreservingPositions(child, newNode, newChildIndex++, positionsToPreserve);\n                }\n                movePreservingPositions(newNode, parentNode, dom.getNodeIndex(descendantNode) + 1, positionsToPreserve);\n                return (descendantNode == node) ? newNode : splitNodeAt(node, parentNode, dom.getNodeIndex(newNode), positionsToPreserve);\n            } else if (node != descendantNode) {\n                newNode = descendantNode.parentNode;\n\n                // Work out a new split point in the parent node\n                var newNodeIndex = dom.getNodeIndex(descendantNode);\n\n                if (!splitAtStart) {\n                    newNodeIndex++;\n                }\n                return splitNodeAt(node, newNode, newNodeIndex, positionsToPreserve);\n            }\n            return node;\n        }\n\n        function areElementsMergeable(el1, el2) {\n            return el1.namespaceURI == el2.namespaceURI &&\n                el1.tagName.toLowerCase() == el2.tagName.toLowerCase() &&\n                haveSameClasses(el1, el2) &&\n                elementsHaveSameNonClassAttributes(el1, el2) &&\n                getComputedStyleProperty(el1, "display") == "inline" &&\n                getComputedStyleProperty(el2, "display") == "inline";\n        }\n\n        function createAdjacentMergeableTextNodeGetter(forward) {\n            var siblingPropName = forward ? "nextSibling" : "previousSibling";\n\n            return function(textNode, checkParentElement) {\n                var el = textNode.parentNode;\n                var adjacentNode = textNode[siblingPropName];\n                if (adjacentNode) {\n                    // Can merge if the node\'s previous/next sibling is a text node\n                    if (adjacentNode && adjacentNode.nodeType == 3) {\n                        return adjacentNode;\n                    }\n                } else if (checkParentElement) {\n                    // Compare text node parent element with its sibling\n                    adjacentNode = el[siblingPropName];\n                    if (adjacentNode && adjacentNode.nodeType == 1 && areElementsMergeable(el, adjacentNode)) {\n                        var adjacentNodeChild = adjacentNode[forward ? "firstChild" : "lastChild"];\n                        if (adjacentNodeChild && adjacentNodeChild.nodeType == 3) {\n                            return adjacentNodeChild;\n                        }\n                    }\n                }\n                return null;\n            };\n        }\n\n        var getPreviousMergeableTextNode = createAdjacentMergeableTextNodeGetter(false),\n            getNextMergeableTextNode = createAdjacentMergeableTextNodeGetter(true);\n\n    \n        function Merge(firstNode) {\n            this.isElementMerge = (firstNode.nodeType == 1);\n            this.textNodes = [];\n            var firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;\n            if (firstTextNode) {\n                this.textNodes[0] = firstTextNode;\n            }\n        }\n\n        Merge.prototype = {\n            doMerge: function(positionsToPreserve) {\n                var textNodes = this.textNodes;\n                var firstTextNode = textNodes[0];\n                if (textNodes.length > 1) {\n                    var firstTextNodeIndex = dom.getNodeIndex(firstTextNode);\n                    var textParts = [], combinedTextLength = 0, textNode, parent;\n                    forEach(textNodes, function(textNode, i) {\n                        parent = textNode.parentNode;\n                        if (i > 0) {\n                            parent.removeChild(textNode);\n                            if (!parent.hasChildNodes()) {\n                                dom.removeNode(parent);\n                            }\n                            if (positionsToPreserve) {\n                                forEach(positionsToPreserve, function(position) {\n                                    // Handle case where position is inside the text node being merged into a preceding node\n                                    if (position.node == textNode) {\n                                        position.node = firstTextNode;\n                                        position.offset += combinedTextLength;\n                                    }\n                                    // Handle case where both text nodes precede the position within the same parent node\n                                    if (position.node == parent && position.offset > firstTextNodeIndex) {\n                                        --position.offset;\n                                        if (position.offset == firstTextNodeIndex + 1 && i < len - 1) {\n                                            position.node = firstTextNode;\n                                            position.offset = combinedTextLength;\n                                        }\n                                    }\n                                });\n                            }\n                        }\n                        textParts[i] = textNode.data;\n                        combinedTextLength += textNode.data.length;\n                    });\n                    firstTextNode.data = textParts.join("");\n                }\n                return firstTextNode.data;\n            },\n\n            getLength: function() {\n                var i = this.textNodes.length, len = 0;\n                while (i--) {\n                    len += this.textNodes[i].length;\n                }\n                return len;\n            },\n\n            toString: function() {\n                var textParts = [];\n                forEach(this.textNodes, function(textNode, i) {\n                    textParts[i] = "\'" + textNode.data + "\'";\n                });\n                return "[Merge(" + textParts.join(",") + ")]";\n            }\n        };\n\n        var optionProperties = ["elementTagName", "ignoreWhiteSpace", "applyToEditableOnly", "useExistingElements",\n            "removeEmptyElements", "onElementCreate"];\n\n        // TODO: Populate this with every attribute name that corresponds to a property with a different name. Really??\n        var attrNamesForProperties = {};\n\n        function ClassApplier(className, options, tagNames) {\n            var normalize, i, len, propName, applier = this;\n            applier.cssClass = applier.className = className; // cssClass property is for backward compatibility\n\n            var elementPropertiesFromOptions = null, elementAttributes = {};\n\n            // Initialize from options object\n            if (typeof options == "object" && options !== null) {\n                if (typeof options.elementTagName !== "undefined") {\n                    options.elementTagName = options.elementTagName.toLowerCase();\n                }\n                tagNames = options.tagNames;\n                elementPropertiesFromOptions = options.elementProperties;\n                elementAttributes = options.elementAttributes;\n\n                for (i = 0; propName = optionProperties[i++]; ) {\n                    if (options.hasOwnProperty(propName)) {\n                        applier[propName] = options[propName];\n                    }\n                }\n                normalize = options.normalize;\n            } else {\n                normalize = options;\n            }\n\n            // Backward compatibility: the second parameter can also be a Boolean indicating to normalize after unapplying\n            applier.normalize = (typeof normalize == "undefined") ? true : normalize;\n\n            // Initialize element properties and attribute exceptions\n            applier.attrExceptions = [];\n            var el = document.createElement(applier.elementTagName);\n            applier.elementProperties = applier.copyPropertiesToElement(elementPropertiesFromOptions, el, true);\n            each(elementAttributes, function(attrName, attrValue) {\n                applier.attrExceptions.push(attrName);\n                // Ensure each attribute value is a string\n                elementAttributes[attrName] = "" + attrValue;\n            });\n            applier.elementAttributes = elementAttributes;\n\n            applier.elementSortedClassName = applier.elementProperties.hasOwnProperty("className") ?\n                sortClassName(applier.elementProperties.className + " " + className) : className;\n\n            // Initialize tag names\n            applier.applyToAnyTagName = false;\n            var type = typeof tagNames;\n            if (type == "string") {\n                if (tagNames == "*") {\n                    applier.applyToAnyTagName = true;\n                } else {\n                    applier.tagNames = trim(tagNames.toLowerCase()).split(/\\s*,\\s*/);\n                }\n            } else if (type == "object" && typeof tagNames.length == "number") {\n                applier.tagNames = [];\n                for (i = 0, len = tagNames.length; i < len; ++i) {\n                    if (tagNames[i] == "*") {\n                        applier.applyToAnyTagName = true;\n                    } else {\n                        applier.tagNames.push(tagNames[i].toLowerCase());\n                    }\n                }\n            } else {\n                applier.tagNames = [applier.elementTagName];\n            }\n        }\n\n        ClassApplier.prototype = {\n            elementTagName: defaultTagName,\n            elementProperties: {},\n            elementAttributes: {},\n            ignoreWhiteSpace: true,\n            applyToEditableOnly: false,\n            useExistingElements: true,\n            removeEmptyElements: true,\n            onElementCreate: null,\n\n            copyPropertiesToElement: function(props, el, createCopy) {\n                var s, elStyle, elProps = {}, elPropsStyle, propValue, elPropValue, attrName;\n\n                for (var p in props) {\n                    if (props.hasOwnProperty(p)) {\n                        propValue = props[p];\n                        elPropValue = el[p];\n\n                        // Special case for class. The copied properties object has the applier\'s class as well as its own\n                        // to simplify checks when removing styling elements\n                        if (p == "className") {\n                            addClass(el, propValue);\n                            addClass(el, this.className);\n                            el[p] = sortClassName(el[p]);\n                            if (createCopy) {\n                                elProps[p] = propValue;\n                            }\n                        }\n\n                        // Special case for style\n                        else if (p == "style") {\n                            elStyle = elPropValue;\n                            if (createCopy) {\n                                elProps[p] = elPropsStyle = {};\n                            }\n                            for (s in props[p]) {\n                                if (props[p].hasOwnProperty(s)) {\n                                    elStyle[s] = propValue[s];\n                                    if (createCopy) {\n                                        elPropsStyle[s] = elStyle[s];\n                                    }\n                                }\n                            }\n                            this.attrExceptions.push(p);\n                        } else {\n                            el[p] = propValue;\n                            // Copy the property back from the dummy element so that later comparisons to check whether\n                            // elements may be removed are checking against the right value. For example, the href property\n                            // of an element returns a fully qualified URL even if it was previously assigned a relative\n                            // URL.\n                            if (createCopy) {\n                                elProps[p] = el[p];\n\n                                // Not all properties map to identically-named attributes\n                                attrName = attrNamesForProperties.hasOwnProperty(p) ? attrNamesForProperties[p] : p;\n                                this.attrExceptions.push(attrName);\n                            }\n                        }\n                    }\n                }\n\n                return createCopy ? elProps : "";\n            },\n\n            copyAttributesToElement: function(attrs, el) {\n                for (var attrName in attrs) {\n                    if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {\n                        el.setAttribute(attrName, attrs[attrName]);\n                    }\n                }\n            },\n\n            appliesToElement: function(el) {\n                return contains(this.tagNames, el.tagName.toLowerCase());\n            },\n\n            getEmptyElements: function(range) {\n                var applier = this;\n                return range.getNodes([1], function(el) {\n                    return applier.appliesToElement(el) && !el.hasChildNodes();\n                });\n            },\n\n            hasClass: function(node) {\n                return node.nodeType == 1 &&\n                    (this.applyToAnyTagName || this.appliesToElement(node)) &&\n                    hasClass(node, this.className);\n            },\n\n            getSelfOrAncestorWithClass: function(node) {\n                while (node) {\n                    if (this.hasClass(node)) {\n                        return node;\n                    }\n                    node = node.parentNode;\n                }\n                return null;\n            },\n\n            isModifiable: function(node) {\n                return !this.applyToEditableOnly || isEditable(node);\n            },\n\n            // White space adjacent to an unwrappable node can be ignored for wrapping\n            isIgnorableWhiteSpaceNode: function(node) {\n                return this.ignoreWhiteSpace && node && node.nodeType == 3 && isUnrenderedWhiteSpaceNode(node);\n            },\n\n            // Normalizes nodes after applying a class to a Range.\n            postApply: function(textNodes, range, positionsToPreserve, isUndo) {\n                var firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];\n\n                var merges = [], currentMerge;\n\n                var rangeStartNode = firstNode, rangeEndNode = lastNode;\n                var rangeStartOffset = 0, rangeEndOffset = lastNode.length;\n\n                var textNode, precedingTextNode;\n\n                // Check for every required merge and create a Merge object for each\n                forEach(textNodes, function(textNode) {\n                    precedingTextNode = getPreviousMergeableTextNode(textNode, !isUndo);\n                    if (precedingTextNode) {\n                        if (!currentMerge) {\n                            currentMerge = new Merge(precedingTextNode);\n                            merges.push(currentMerge);\n                        }\n                        currentMerge.textNodes.push(textNode);\n                        if (textNode === firstNode) {\n                            rangeStartNode = currentMerge.textNodes[0];\n                            rangeStartOffset = rangeStartNode.length;\n                        }\n                        if (textNode === lastNode) {\n                            rangeEndNode = currentMerge.textNodes[0];\n                            rangeEndOffset = currentMerge.getLength();\n                        }\n                    } else {\n                        currentMerge = null;\n                    }\n                });\n\n                // Test whether the first node after the range needs merging\n                var nextTextNode = getNextMergeableTextNode(lastNode, !isUndo);\n\n                if (nextTextNode) {\n                    if (!currentMerge) {\n                        currentMerge = new Merge(lastNode);\n                        merges.push(currentMerge);\n                    }\n                    currentMerge.textNodes.push(nextTextNode);\n                }\n\n                // Apply the merges\n                if (merges.length) {\n                    for (i = 0, len = merges.length; i < len; ++i) {\n                        merges[i].doMerge(positionsToPreserve);\n                    }\n\n                    // Set the range boundaries\n                    range.setStartAndEnd(rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);\n                }\n            },\n\n            createContainer: function(parentNode) {\n                var doc = dom.getDocument(parentNode);\n                var namespace;\n                var el = createElementNSSupported && !dom.isHtmlNamespace(parentNode) && (namespace = parentNode.namespaceURI) ?\n                    doc.createElementNS(parentNode.namespaceURI, this.elementTagName) :\n                    doc.createElement(this.elementTagName);\n\n                this.copyPropertiesToElement(this.elementProperties, el, false);\n                this.copyAttributesToElement(this.elementAttributes, el);\n                addClass(el, this.className);\n                if (this.onElementCreate) {\n                    this.onElementCreate(el, this);\n                }\n                return el;\n            },\n\n            elementHasProperties: function(el, props) {\n                var applier = this;\n                return each(props, function(p, propValue) {\n                    if (p == "className") {\n                        // For checking whether we should reuse an existing element, we just want to check that the element\n                        // has all the classes specified in the className property. When deciding whether the element is\n                        // removable when unapplying a class, there is separate special handling to check whether the\n                        // element has extra classes so the same simple check will do.\n                        return hasAllClasses(el, propValue);\n                    } else if (typeof propValue == "object") {\n                        if (!applier.elementHasProperties(el[p], propValue)) {\n                            return false;\n                        }\n                    } else if (el[p] !== propValue) {\n                        return false;\n                    }\n                });\n            },\n\n            elementHasAttributes: function(el, attrs) {\n                return each(attrs, function(name, value) {\n                    if (el.getAttribute(name) !== value) {\n                        return false;\n                    }\n                });\n            },\n\n            applyToTextNode: function(textNode, positionsToPreserve) {\n\n                // Check whether the text node can be styled. Text within a <style> or <script> element, for example,\n                // should not be styled. See issue 283.\n                if (canTextBeStyled(textNode)) {\n                    var parent = textNode.parentNode;\n                    if (parent.childNodes.length == 1 &&\n                        this.useExistingElements &&\n                        this.appliesToElement(parent) &&\n                        this.elementHasProperties(parent, this.elementProperties) &&\n                        this.elementHasAttributes(parent, this.elementAttributes)) {\n\n                        addClass(parent, this.className);\n                    } else {\n                        var textNodeParent = textNode.parentNode;\n                        var el = this.createContainer(textNodeParent);\n                        textNodeParent.insertBefore(el, textNode);\n                        el.appendChild(textNode);\n                    }\n                }\n\n            },\n\n            isRemovable: function(el) {\n                return el.tagName.toLowerCase() == this.elementTagName &&\n                    getSortedClassName(el) == this.elementSortedClassName &&\n                    this.elementHasProperties(el, this.elementProperties) &&\n                    !elementHasNonClassAttributes(el, this.attrExceptions) &&\n                    this.elementHasAttributes(el, this.elementAttributes) &&\n                    this.isModifiable(el);\n            },\n\n            isEmptyContainer: function(el) {\n                var childNodeCount = el.childNodes.length;\n                return el.nodeType == 1 &&\n                    this.isRemovable(el) &&\n                    (childNodeCount == 0 || (childNodeCount == 1 && this.isEmptyContainer(el.firstChild)));\n            },\n\n            removeEmptyContainers: function(range) {\n                var applier = this;\n                var nodesToRemove = range.getNodes([1], function(el) {\n                    return applier.isEmptyContainer(el);\n                });\n\n                var rangesToPreserve = [range];\n                var positionsToPreserve = getRangeBoundaries(rangesToPreserve);\n\n                forEach(nodesToRemove, function(node) {\n                    removePreservingPositions(node, positionsToPreserve);\n                });\n\n                // Update the range from the preserved boundary positions\n                updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n            },\n\n            undoToTextNode: function(textNode, range, ancestorWithClass, positionsToPreserve) {\n                if (!range.containsNode(ancestorWithClass)) {\n                    // Split out the portion of the ancestor from which we can remove the class\n                    //var parent = ancestorWithClass.parentNode, index = dom.getNodeIndex(ancestorWithClass);\n                    var ancestorRange = range.cloneRange();\n                    ancestorRange.selectNode(ancestorWithClass);\n                    if (ancestorRange.isPointInRange(range.endContainer, range.endOffset)) {\n                        splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset, positionsToPreserve);\n                        range.setEndAfter(ancestorWithClass);\n                    }\n                    if (ancestorRange.isPointInRange(range.startContainer, range.startOffset)) {\n                        ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset, positionsToPreserve);\n                    }\n                }\n\n                if (this.isRemovable(ancestorWithClass)) {\n                    replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);\n                } else {\n                    removeClass(ancestorWithClass, this.className);\n                }\n            },\n\n            splitAncestorWithClass: function(container, offset, positionsToPreserve) {\n                var ancestorWithClass = this.getSelfOrAncestorWithClass(container);\n                if (ancestorWithClass) {\n                    splitNodeAt(ancestorWithClass, container, offset, positionsToPreserve);\n                }\n            },\n\n            undoToAncestor: function(ancestorWithClass, positionsToPreserve) {\n                if (this.isRemovable(ancestorWithClass)) {\n                    replaceWithOwnChildrenPreservingPositions(ancestorWithClass, positionsToPreserve);\n                } else {\n                    removeClass(ancestorWithClass, this.className);\n                }\n            },\n\n            applyToRange: function(range, rangesToPreserve) {\n                var applier = this;\n                rangesToPreserve = rangesToPreserve || [];\n\n                // Create an array of range boundaries to preserve\n                var positionsToPreserve = getRangeBoundaries(rangesToPreserve || []);\n\n                range.splitBoundariesPreservingPositions(positionsToPreserve);\n\n                // Tidy up the DOM by removing empty containers\n                if (applier.removeEmptyElements) {\n                    applier.removeEmptyContainers(range);\n                }\n\n                var textNodes = getEffectiveTextNodes(range);\n\n                if (textNodes.length) {\n                    forEach(textNodes, function(textNode) {\n                        if (!applier.isIgnorableWhiteSpaceNode(textNode) && !applier.getSelfOrAncestorWithClass(textNode) &&\n                                applier.isModifiable(textNode)) {\n                            applier.applyToTextNode(textNode, positionsToPreserve);\n                        }\n                    });\n                    var lastTextNode = textNodes[textNodes.length - 1];\n                    range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);\n                    if (applier.normalize) {\n                        applier.postApply(textNodes, range, positionsToPreserve, false);\n                    }\n\n                    // Update the ranges from the preserved boundary positions\n                    updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n                }\n\n                // Apply classes to any appropriate empty elements\n                var emptyElements = applier.getEmptyElements(range);\n\n                forEach(emptyElements, function(el) {\n                    addClass(el, applier.className);\n                });\n            },\n\n            applyToRanges: function(ranges) {\n\n                var i = ranges.length;\n                while (i--) {\n                    this.applyToRange(ranges[i], ranges);\n                }\n\n\n                return ranges;\n            },\n\n            applyToSelection: function(win) {\n                var sel = api.getSelection(win);\n                sel.setRanges( this.applyToRanges(sel.getAllRanges()) );\n            },\n\n            undoToRange: function(range, rangesToPreserve) {\n                var applier = this;\n                // Create an array of range boundaries to preserve\n                rangesToPreserve = rangesToPreserve || [];\n                var positionsToPreserve = getRangeBoundaries(rangesToPreserve);\n\n\n                range.splitBoundariesPreservingPositions(positionsToPreserve);\n\n                // Tidy up the DOM by removing empty containers\n                if (applier.removeEmptyElements) {\n                    applier.removeEmptyContainers(range, positionsToPreserve);\n                }\n\n                var textNodes = getEffectiveTextNodes(range);\n                var textNode, ancestorWithClass;\n                var lastTextNode = textNodes[textNodes.length - 1];\n\n                if (textNodes.length) {\n                    applier.splitAncestorWithClass(range.endContainer, range.endOffset, positionsToPreserve);\n                    applier.splitAncestorWithClass(range.startContainer, range.startOffset, positionsToPreserve);\n                    for (var i = 0, len = textNodes.length; i < len; ++i) {\n                        textNode = textNodes[i];\n                        ancestorWithClass = applier.getSelfOrAncestorWithClass(textNode);\n                        if (ancestorWithClass && applier.isModifiable(textNode)) {\n                            applier.undoToAncestor(ancestorWithClass, positionsToPreserve);\n                        }\n                    }\n                    // Ensure the range is still valid\n                    range.setStartAndEnd(textNodes[0], 0, lastTextNode, lastTextNode.length);\n\n\n                    if (applier.normalize) {\n                        applier.postApply(textNodes, range, positionsToPreserve, true);\n                    }\n\n                    // Update the ranges from the preserved boundary positions\n                    updateRangesFromBoundaries(rangesToPreserve, positionsToPreserve);\n                }\n\n                // Remove class from any appropriate empty elements\n                var emptyElements = applier.getEmptyElements(range);\n\n                forEach(emptyElements, function(el) {\n                    removeClass(el, applier.className);\n                });\n            },\n\n            undoToRanges: function(ranges) {\n                // Get ranges returned in document order\n                var i = ranges.length;\n\n                while (i--) {\n                    this.undoToRange(ranges[i], ranges);\n                }\n\n                return ranges;\n            },\n\n            undoToSelection: function(win) {\n                var sel = api.getSelection(win);\n                var ranges = api.getSelection(win).getAllRanges();\n                this.undoToRanges(ranges);\n                sel.setRanges(ranges);\n            },\n\n            isAppliedToRange: function(range) {\n                if (range.collapsed || range.toString() == "") {\n                    return !!this.getSelfOrAncestorWithClass(range.commonAncestorContainer);\n                } else {\n                    var textNodes = range.getNodes( [3] );\n                    if (textNodes.length)\n                    for (var i = 0, textNode; textNode = textNodes[i++]; ) {\n                        if (!this.isIgnorableWhiteSpaceNode(textNode) && rangeSelectsAnyText(range, textNode) &&\n                                this.isModifiable(textNode) && !this.getSelfOrAncestorWithClass(textNode)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            },\n\n            isAppliedToRanges: function(ranges) {\n                var i = ranges.length;\n                if (i == 0) {\n                    return false;\n                }\n                while (i--) {\n                    if (!this.isAppliedToRange(ranges[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n\n            isAppliedToSelection: function(win) {\n                var sel = api.getSelection(win);\n                return this.isAppliedToRanges(sel.getAllRanges());\n            },\n\n            toggleRange: function(range) {\n                if (this.isAppliedToRange(range)) {\n                    this.undoToRange(range);\n                } else {\n                    this.applyToRange(range);\n                }\n            },\n\n            toggleSelection: function(win) {\n                if (this.isAppliedToSelection(win)) {\n                    this.undoToSelection(win);\n                } else {\n                    this.applyToSelection(win);\n                }\n            },\n\n            getElementsWithClassIntersectingRange: function(range) {\n                var elements = [];\n                var applier = this;\n                range.getNodes([3], function(textNode) {\n                    var el = applier.getSelfOrAncestorWithClass(textNode);\n                    if (el && !contains(elements, el)) {\n                        elements.push(el);\n                    }\n                });\n                return elements;\n            },\n\n            detach: function() {}\n        };\n\n        function createClassApplier(className, options, tagNames) {\n            return new ClassApplier(className, options, tagNames);\n        }\n\n        ClassApplier.util = {\n            hasClass: hasClass,\n            addClass: addClass,\n            removeClass: removeClass,\n            getClass: getClass,\n            hasSameClasses: haveSameClasses,\n            hasAllClasses: hasAllClasses,\n            replaceWithOwnChildren: replaceWithOwnChildrenPreservingPositions,\n            elementsHaveSameNonClassAttributes: elementsHaveSameNonClassAttributes,\n            elementHasNonClassAttributes: elementHasNonClassAttributes,\n            splitNodeAt: splitNodeAt,\n            isEditableElement: isEditableElement,\n            isEditingHost: isEditingHost,\n            isEditable: isEditable\n        };\n\n        api.CssClassApplier = api.ClassApplier = ClassApplier;\n        api.createClassApplier = createClassApplier;\n        util.createAliasForDeprecatedMethod(api, "createCssClassApplier", "createClassApplier", module);\n    });\n    \n    return rangy;\n})(_rangy_core_js__WEBPACK_IMPORTED_MODULE_0__.rangy);\n\n\n//# sourceURL=webpack://appjs/./src/lib/rangy-classapplier.js?')},"./src/lib/rangy-core.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rangy: () => (/* binding */ api)\n/* harmony export */ });\n/**\n * Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\nvar api = (function() {\n\n    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";\n\n    // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START\n    // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.\n    var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",\n        "commonAncestorContainer"];\n\n    // Minimal set of methods required for DOM Level 2 Range compliance\n    var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore",\n        "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents",\n        "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];\n\n    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];\n\n    // Subset of TextRange\'s full set of methods that we\'re interested in\n    var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "moveToElementText", "parentElement", "select",\n        "setEndPoint", "getBoundingClientRect"];\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Trio of functions taken from Peter Michaux\'s article:\n    // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n    function isHostMethod(o, p) {\n        var t = typeof o[p];\n        return t == FUNCTION || (!!(t == OBJECT && o[p])) || t == "unknown";\n    }\n\n    function isHostObject(o, p) {\n        return !!(typeof o[p] == OBJECT && o[p]);\n    }\n\n    function isHostProperty(o, p) {\n        return typeof o[p] != UNDEFINED;\n    }\n\n    // Creates a convenience function to save verbose repeated calls to tests functions\n    function createMultiplePropertyTest(testFunc) {\n        return function(o, props) {\n            var i = props.length;\n            while (i--) {\n                if (!testFunc(o, props[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n    var areHostMethods = createMultiplePropertyTest(isHostMethod);\n    var areHostObjects = createMultiplePropertyTest(isHostObject);\n    var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n    function isTextRange(range) {\n        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n    }\n\n    function getBody(doc) {\n        return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];\n    }\n\n    var forEach = [].forEach ?\n        function(arr, func) {\n            arr.forEach(func);\n        } :\n        function(arr, func) {\n            for (var i = 0, len = arr.length; i < len; ++i) {\n                func(arr[i], i);\n            }\n        };\n\n    var modules = {};\n\n    var isBrowser = (typeof window != UNDEFINED && typeof document != UNDEFINED);\n\n    var util = {\n        isHostMethod: isHostMethod,\n        isHostObject: isHostObject,\n        isHostProperty: isHostProperty,\n        areHostMethods: areHostMethods,\n        areHostObjects: areHostObjects,\n        areHostProperties: areHostProperties,\n        isTextRange: isTextRange,\n        getBody: getBody,\n        forEach: forEach\n    };\n\n    var api = {\n        version: "1.3.1-dev",\n        initialized: false,\n        isBrowser: isBrowser,\n        supported: true,\n        util: util,\n        features: {},\n        modules: modules,\n        config: {\n            alertOnFail: false,\n            alertOnWarn: false,\n            preferTextRange: false,\n            autoInitialize: (typeof rangyAutoInitialize == UNDEFINED) ? true : rangyAutoInitialize\n        }\n    };\n\n    function consoleLog(msg) {\n        if (typeof console != UNDEFINED && isHostMethod(console, "log")) {\n            console.log(msg);\n        }\n    }\n\n    function alertOrLog(msg, shouldAlert) {\n        if (isBrowser && shouldAlert) {\n            alert(msg);\n        } else  {\n            consoleLog(msg);\n        }\n    }\n\n    function fail(reason) {\n        api.initialized = true;\n        api.supported = false;\n        alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);\n    }\n\n    api.fail = fail;\n\n    function warn(msg) {\n        alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);\n    }\n\n    api.warn = warn;\n\n    // Add utility extend() method\n    var extend;\n    if ({}.hasOwnProperty) {\n        util.extend = extend = function(obj, props, deep) {\n            var o, p;\n            for (var i in props) {\n                if (props.hasOwnProperty(i)) {\n                    o = obj[i];\n                    p = props[i];\n                    if (deep && o !== null && typeof o == "object" && p !== null && typeof p == "object") {\n                        extend(o, p, true);\n                    }\n                    obj[i] = p;\n                }\n            }\n            // Special case for toString, which does not show up in for...in loops in IE <= 8\n            if (props.hasOwnProperty("toString")) {\n                obj.toString = props.toString;\n            }\n            return obj;\n        };\n\n        util.createOptions = function(optionsParam, defaults) {\n            var options = {};\n            extend(options, defaults);\n            if (optionsParam) {\n                extend(options, optionsParam);\n            }\n            return options;\n        };\n    } else {\n        fail("hasOwnProperty not supported");\n    }\n\n    // Test whether we\'re in a browser and bail out if not\n    if (!isBrowser) {\n        fail("Rangy can only run in a browser");\n    }\n\n    // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not\n    (function() {\n        var toArray;\n\n        if (isBrowser) {\n            var el = document.createElement("div");\n            el.appendChild(document.createElement("span"));\n            var slice = [].slice;\n            try {\n                if (slice.call(el.childNodes, 0)[0].nodeType == 1) {\n                    toArray = function(arrayLike) {\n                        return slice.call(arrayLike, 0);\n                    };\n                }\n            } catch (e) {}\n        }\n\n        if (!toArray) {\n            toArray = function(arrayLike) {\n                var arr = [];\n                for (var i = 0, len = arrayLike.length; i < len; ++i) {\n                    arr[i] = arrayLike[i];\n                }\n                return arr;\n            };\n        }\n\n        util.toArray = toArray;\n    })();\n\n    // Very simple event handler wrapper function that doesn\'t attempt to solve issues such as "this" handling or\n    // normalization of event properties\n    var addListener;\n    if (isBrowser) {\n        if (isHostMethod(document, "addEventListener")) {\n            addListener = function(obj, eventType, listener) {\n                obj.addEventListener(eventType, listener, false);\n            };\n        } else if (isHostMethod(document, "attachEvent")) {\n            addListener = function(obj, eventType, listener) {\n                obj.attachEvent("on" + eventType, listener);\n            };\n        } else {\n            fail("Document does not have required addEventListener or attachEvent method");\n        }\n\n        util.addListener = addListener;\n    }\n\n    var initListeners = [];\n\n    function getErrorDesc(ex) {\n        return ex.message || ex.description || String(ex);\n    }\n\n    // Initialization\n    function init() {\n        if (!isBrowser || api.initialized) {\n            return;\n        }\n        var testRange;\n        var implementsDomRange = false, implementsTextRange = false;\n\n        // First, perform basic feature tests\n\n        if (isHostMethod(document, "createRange")) {\n            testRange = document.createRange();\n            if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n                implementsDomRange = true;\n            }\n        }\n\n        var body = getBody(document);\n        if (!body || body.nodeName.toLowerCase() != "body") {\n            fail("No body element found");\n            return;\n        }\n\n        if (body && isHostMethod(body, "createTextRange")) {\n            testRange = body.createTextRange();\n            if (isTextRange(testRange)) {\n                implementsTextRange = true;\n            }\n        }\n\n        if (!implementsDomRange && !implementsTextRange) {\n            fail("Neither Range nor TextRange are available");\n            return;\n        }\n\n        api.initialized = true;\n        api.features = {\n            implementsDomRange: implementsDomRange,\n            implementsTextRange: implementsTextRange\n        };\n\n        // Initialize modules\n        var module, errorMessage;\n        for (var moduleName in modules) {\n            if ( (module = modules[moduleName]) instanceof Module ) {\n                module.init(module, api);\n            }\n        }\n\n        // Call init listeners\n        for (var i = 0, len = initListeners.length; i < len; ++i) {\n            try {\n                initListeners[i](api);\n            } catch (ex) {\n                errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);\n                consoleLog(errorMessage);\n            }\n        }\n    }\n\n    function deprecationNotice(deprecated, replacement, module) {\n        if (module) {\n            deprecated += " in module " + module.name;\n        }\n        api.warn("DEPRECATED: " + deprecated + " is deprecated. Please use " +\n        replacement + " instead.");\n    }\n\n    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {\n        owner[deprecated] = function() {\n            deprecationNotice(deprecated, replacement, module);\n            return owner[replacement].apply(owner, util.toArray(arguments));\n        };\n    }\n\n    util.deprecationNotice = deprecationNotice;\n    util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;\n\n    // Allow external scripts to initialize this library in case it\'s loaded after the document has loaded\n    api.init = init;\n\n    // Execute listener immediately if already initialized\n    api.addInitListener = function(listener) {\n        if (api.initialized) {\n            listener(api);\n        } else {\n            initListeners.push(listener);\n        }\n    };\n\n    var shimListeners = [];\n\n    api.addShimListener = function(listener) {\n        shimListeners.push(listener);\n    };\n\n    function shim(win) {\n        win = win || window;\n        init();\n\n        // Notify listeners\n        for (var i = 0, len = shimListeners.length; i < len; ++i) {\n            shimListeners[i](win);\n        }\n    }\n\n    if (isBrowser) {\n        api.shim = api.createMissingNativeApi = shim;\n        createAliasForDeprecatedMethod(api, "createMissingNativeApi", "shim");\n    }\n\n    function Module(name, dependencies, initializer) {\n        this.name = name;\n        this.dependencies = dependencies;\n        this.initialized = false;\n        this.supported = false;\n        this.initializer = initializer;\n    }\n\n    Module.prototype = {\n        init: function() {\n            var requiredModuleNames = this.dependencies || [];\n            for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {\n                moduleName = requiredModuleNames[i];\n\n                requiredModule = modules[moduleName];\n                if (!requiredModule || !(requiredModule instanceof Module)) {\n                    throw new Error("required module \'" + moduleName + "\' not found");\n                }\n\n                requiredModule.init();\n\n                if (!requiredModule.supported) {\n                    throw new Error("required module \'" + moduleName + "\' not supported");\n                }\n            }\n\n            // Now run initializer\n            this.initializer(this);\n        },\n\n        fail: function(reason) {\n            this.initialized = true;\n            this.supported = false;\n            throw new Error(reason);\n        },\n\n        warn: function(msg) {\n            api.warn("Module " + this.name + ": " + msg);\n        },\n\n        deprecationNotice: function(deprecated, replacement) {\n            api.warn("DEPRECATED: " + deprecated + " in module " + this.name + " is deprecated. Please use " +\n                replacement + " instead");\n        },\n\n        createError: function(msg) {\n            return new Error("Error in Rangy " + this.name + " module: " + msg);\n        }\n    };\n\n    function createModule(name, dependencies, initFunc) {\n        var newModule = new Module(name, dependencies, function(module) {\n            if (!module.initialized) {\n                module.initialized = true;\n                try {\n                    initFunc(api, module);\n                    module.supported = true;\n                } catch (ex) {\n                    var errorMessage = "Module \'" + name + "\' failed to load: " + getErrorDesc(ex);\n                    consoleLog(errorMessage);\n                    if (ex.stack) {\n                        consoleLog(ex.stack);\n                    }\n                }\n            }\n        });\n        modules[name] = newModule;\n        return newModule;\n    }\n\n    api.createModule = function(name) {\n        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)\n        var initFunc, dependencies;\n        if (arguments.length == 2) {\n            initFunc = arguments[1];\n            dependencies = [];\n        } else {\n            initFunc = arguments[2];\n            dependencies = arguments[1];\n        }\n\n        var module = createModule(name, dependencies, initFunc);\n\n        // Initialize the module immediately if the core is already initialized\n        if (api.initialized && api.supported) {\n            module.init();\n        }\n    };\n\n    api.createCoreModule = function(name, dependencies, initFunc) {\n        createModule(name, dependencies, initFunc);\n    };\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately\n\n    function RangePrototype() {}\n    api.RangePrototype = RangePrototype;\n    api.rangePrototype = new RangePrototype();\n\n    function SelectionPrototype() {}\n    api.selectionPrototype = new SelectionPrototype();\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // DOM utility methods used by Rangy\n    api.createCoreModule("DomUtil", [], function(api, module) {\n        var UNDEF = "undefined";\n        var util = api.util;\n        var getBody = util.getBody;\n\n        // Perform feature tests\n        if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {\n            module.fail("document missing a Node creation method");\n        }\n\n        if (!util.isHostMethod(document, "getElementsByTagName")) {\n            module.fail("document missing getElementsByTagName method");\n        }\n\n        var el = document.createElement("div");\n        if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] ||\n                0)) {\n            module.fail("Incomplete Element implementation");\n        }\n\n        // innerHTML is required for Range\'s createContextualFragment method\n        if (!util.isHostProperty(el, "innerHTML")) {\n            module.fail("Element is missing innerHTML property");\n        }\n\n        var textNode = document.createTextNode("test");\n        if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] ||\n                0 ||\n                0)) {\n            module.fail("Incomplete Text Node implementation");\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven\'t been\n        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n        // contains just the document as a single element and the value searched for is the document.\n        var arrayContains = /*Array.prototype.indexOf ?\n            function(arr, val) {\n                return arr.indexOf(val) > -1;\n            }:*/\n\n            function(arr, val) {\n                var i = arr.length;\n                while (i--) {\n                    if (arr[i] === val) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n\n        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n        function isHtmlNamespace(node) {\n            var ns;\n            return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");\n        }\n\n        function parentElement(node) {\n            var parent = node.parentNode;\n            return (parent.nodeType == 1) ? parent : null;\n        }\n\n        function getNodeIndex(node) {\n            var i = 0;\n            while( (node = node.previousSibling) ) {\n                ++i;\n            }\n            return i;\n        }\n\n        function getNodeLength(node) {\n            switch (node.nodeType) {\n                case 7:\n                case 10:\n                    return 0;\n                case 3:\n                case 8:\n                    return node.length;\n                default:\n                    return node.childNodes.length;\n            }\n        }\n\n        function getCommonAncestor(node1, node2) {\n            var ancestors = [], n;\n            for (n = node1; n; n = n.parentNode) {\n                ancestors.push(n);\n            }\n\n            for (n = node2; n; n = n.parentNode) {\n                if (arrayContains(ancestors, n)) {\n                    return n;\n                }\n            }\n\n            return null;\n        }\n\n        function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n            var n = selfIsAncestor ? descendant : descendant.parentNode;\n            while (n) {\n                if (n === ancestor) {\n                    return true;\n                } else {\n                    n = n.parentNode;\n                }\n            }\n            return false;\n        }\n\n        function isOrIsAncestorOf(ancestor, descendant) {\n            return isAncestorOf(ancestor, descendant, true);\n        }\n\n        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n            var p, n = selfIsAncestor ? node : node.parentNode;\n            while (n) {\n                p = n.parentNode;\n                if (p === ancestor) {\n                    return n;\n                }\n                n = p;\n            }\n            return null;\n        }\n\n        function isCharacterDataNode(node) {\n            var t = node.nodeType;\n            return t == 3 || t == 4 || t == 8 ; // Text, CDataSection or Comment\n        }\n\n        function isTextOrCommentNode(node) {\n            if (!node) {\n                return false;\n            }\n            var t = node.nodeType;\n            return t == 3 || t == 8 ; // Text or Comment\n        }\n\n        function insertAfter(node, precedingNode) {\n            var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;\n            if (nextNode) {\n                parent.insertBefore(node, nextNode);\n            } else {\n                parent.appendChild(node);\n            }\n            return node;\n        }\n\n        // Note that we cannot use splitText() because it is bugridden in IE 9.\n        function splitDataNode(node, index, positionsToPreserve) {\n            var newNode = node.cloneNode(false);\n            newNode.deleteData(0, index);\n            node.deleteData(index, node.length - index);\n            insertAfter(newNode, node);\n\n            // Preserve positions\n            if (positionsToPreserve) {\n                for (var i = 0, position; position = positionsToPreserve[i++]; ) {\n                    // Handle case where position was inside the portion of node after the split point\n                    if (position.node == node && position.offset > index) {\n                        position.node = newNode;\n                        position.offset -= index;\n                    }\n                    // Handle the case where the position is a node offset within node\'s parent\n                    else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {\n                        ++position.offset;\n                    }\n                }\n            }\n            return newNode;\n        }\n\n        function getDocument(node) {\n            if (node.nodeType == 9) {\n                return node;\n            } else if (typeof node.ownerDocument != UNDEF) {\n                return node.ownerDocument;\n            } else if (typeof node.document != UNDEF) {\n                return node.document;\n            } else if (node.parentNode) {\n                return getDocument(node.parentNode);\n            } else {\n                throw module.createError("getDocument: no document found for node");\n            }\n        }\n\n        function getWindow(node) {\n            var doc = getDocument(node);\n            if (typeof doc.defaultView != UNDEF) {\n                return doc.defaultView;\n            } else if (typeof doc.parentWindow != UNDEF) {\n                return doc.parentWindow;\n            } else {\n                throw module.createError("Cannot get a window object for node");\n            }\n        }\n\n        function getIframeDocument(iframeEl) {\n            if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument;\n            } else if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow.document;\n            } else {\n                throw module.createError("getIframeDocument: No Document object found for iframe element");\n            }\n        }\n\n        function getIframeWindow(iframeEl) {\n            if (typeof iframeEl.contentWindow != UNDEF) {\n                return iframeEl.contentWindow;\n            } else if (typeof iframeEl.contentDocument != UNDEF) {\n                return iframeEl.contentDocument.defaultView;\n            } else {\n                throw module.createError("getIframeWindow: No Window object found for iframe element");\n            }\n        }\n\n        // This looks bad. Is it worth it?\n        function isWindow(obj) {\n            return obj && util.isHostMethod(obj, "setTimeout") && util.isHostObject(obj, "document");\n        }\n\n        function getContentDocument(obj, module, methodName) {\n            var doc;\n\n            if (!obj) {\n                doc = document;\n            }\n\n            // Test if a DOM node has been passed and obtain a document object for it if so\n            else if (util.isHostProperty(obj, "nodeType")) {\n                doc = (obj.nodeType == 1 && obj.tagName.toLowerCase() == "iframe") ?\n                    getIframeDocument(obj) : getDocument(obj);\n            }\n\n            // Test if the doc parameter appears to be a Window object\n            else if (isWindow(obj)) {\n                doc = obj.document;\n            }\n\n            if (!doc) {\n                throw module.createError(methodName + "(): Parameter must be a Window object or DOM node");\n            }\n\n            return doc;\n        }\n\n        function getRootContainer(node) {\n            var parent;\n            while ( (parent = node.parentNode) ) {\n                node = parent;\n            }\n            return node;\n        }\n\n        function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n            // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n            var nodeC, root, childA, childB, n;\n            if (nodeA == nodeB) {\n                // Case 1: nodes are the same\n                return offsetA === offsetB ? 0 : (offsetA < offsetB) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) ) {\n                // Case 2: node C (container B or an ancestor) is a child node of A\n                return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n            } else if ( (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) ) {\n                // Case 3: node C (container A or an ancestor) is a child node of B\n                return getNodeIndex(nodeC) < offsetB  ? -1 : 1;\n            } else {\n                root = getCommonAncestor(nodeA, nodeB);\n                if (!root) {\n                    throw new Error("comparePoints error: nodes have no common ancestor");\n                }\n\n                // Case 4: containers are siblings or descendants of siblings\n                childA = (nodeA === root) ? root : getClosestAncestorIn(nodeA, root, true);\n                childB = (nodeB === root) ? root : getClosestAncestorIn(nodeB, root, true);\n\n                if (childA === childB) {\n                    // This shouldn\'t be possible\n                    throw module.createError("comparePoints got to case 4 and childA and childB are the same!");\n                } else {\n                    n = root.firstChild;\n                    while (n) {\n                        if (n === childA) {\n                            return -1;\n                        } else if (n === childB) {\n                            return 1;\n                        }\n                        n = n.nextSibling;\n                    }\n                }\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test for IE\'s crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried\n        var crashyTextNodes = false;\n\n        function isBrokenNode(node) {\n            var n;\n            try {\n                n = node.parentNode;\n                return false;\n            } catch (e) {\n                return true;\n            }\n        }\n\n        (function() {\n            var el = document.createElement("b");\n            el.innerHTML = "1";\n            var textNode = el.firstChild;\n            el.innerHTML = "<br />";\n            crashyTextNodes = isBrokenNode(textNode);\n\n            api.features.crashyTextNodes = crashyTextNodes;\n        })();\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        function inspectNode(node) {\n            if (!node) {\n                return "[No node]";\n            }\n            if (crashyTextNodes && isBrokenNode(node)) {\n                return "[Broken node]";\n            }\n            if (isCharacterDataNode(node)) {\n                return \'"\' + node.data + \'"\';\n            }\n            if (node.nodeType == 1) {\n                var idAttr = node.id ? \' id="\' + node.id + \'"\' : "";\n                return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";\n            }\n            return node.nodeName;\n        }\n\n        function fragmentFromNodeChildren(node) {\n            var fragment = getDocument(node).createDocumentFragment(), child;\n            while ( (child = node.firstChild) ) {\n                fragment.appendChild(child);\n            }\n            return fragment;\n        }\n\n        var getComputedStyleProperty;\n        if (typeof window.getComputedStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return getWindow(el).getComputedStyle(el, null)[propName];\n            };\n        } else if (typeof document.documentElement.currentStyle != UNDEF) {\n            getComputedStyleProperty = function(el, propName) {\n                return el.currentStyle ? el.currentStyle[propName] : "";\n            };\n        } else {\n            module.fail("No means of obtaining computed style properties found");\n        }\n\n        function createTestElement(doc, html, contentEditable) {\n            var body = getBody(doc);\n            var el = doc.createElement("div");\n            el.contentEditable = "" + !!contentEditable;\n            if (html) {\n                el.innerHTML = html;\n            }\n\n            // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)\n            var bodyFirstChild = body.firstChild;\n            if (bodyFirstChild) {\n                body.insertBefore(el, bodyFirstChild);\n            } else {\n                body.appendChild(el);\n            }\n\n            return el;\n        }\n\n        function removeNode(node) {\n            return node.parentNode.removeChild(node);\n        }\n\n        function NodeIterator(root) {\n            this.root = root;\n            this._next = root;\n        }\n\n        NodeIterator.prototype = {\n            _current: null,\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                var n = this._current = this._next;\n                var child, next;\n                if (this._current) {\n                    child = n.firstChild;\n                    if (child) {\n                        this._next = child;\n                    } else {\n                        next = null;\n                        while ((n !== this.root) && !(next = n.nextSibling)) {\n                            n = n.parentNode;\n                        }\n                        this._next = next;\n                    }\n                }\n                return this._current;\n            },\n\n            detach: function() {\n                this._current = this._next = this.root = null;\n            }\n        };\n\n        function createIterator(root) {\n            return new NodeIterator(root);\n        }\n\n        function DomPosition(node, offset) {\n            this.node = node;\n            this.offset = offset;\n        }\n\n        DomPosition.prototype = {\n            equals: function(pos) {\n                return !!pos && this.node === pos.node && this.offset == pos.offset;\n            },\n\n            inspect: function() {\n                return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";\n            },\n\n            toString: function() {\n                return this.inspect();\n            }\n        };\n\n        function DOMException(codeName) {\n            this.code = this[codeName];\n            this.codeName = codeName;\n            this.message = "DOMException: " + this.codeName;\n        }\n\n        DOMException.prototype = {\n            INDEX_SIZE_ERR: 1,\n            HIERARCHY_REQUEST_ERR: 3,\n            WRONG_DOCUMENT_ERR: 4,\n            NO_MODIFICATION_ALLOWED_ERR: 7,\n            NOT_FOUND_ERR: 8,\n            NOT_SUPPORTED_ERR: 9,\n            INVALID_STATE_ERR: 11,\n            INVALID_NODE_TYPE_ERR: 24\n        };\n\n        DOMException.prototype.toString = function() {\n            return this.message;\n        };\n\n        api.dom = {\n            arrayContains: arrayContains,\n            isHtmlNamespace: isHtmlNamespace,\n            parentElement: parentElement,\n            getNodeIndex: getNodeIndex,\n            getNodeLength: getNodeLength,\n            getCommonAncestor: getCommonAncestor,\n            isAncestorOf: isAncestorOf,\n            isOrIsAncestorOf: isOrIsAncestorOf,\n            getClosestAncestorIn: getClosestAncestorIn,\n            isCharacterDataNode: isCharacterDataNode,\n            isTextOrCommentNode: isTextOrCommentNode,\n            insertAfter: insertAfter,\n            splitDataNode: splitDataNode,\n            getDocument: getDocument,\n            getWindow: getWindow,\n            getIframeWindow: getIframeWindow,\n            getIframeDocument: getIframeDocument,\n            getBody: getBody,\n            isWindow: isWindow,\n            getContentDocument: getContentDocument,\n            getRootContainer: getRootContainer,\n            comparePoints: comparePoints,\n            isBrokenNode: isBrokenNode,\n            inspectNode: inspectNode,\n            getComputedStyleProperty: getComputedStyleProperty,\n            createTestElement: createTestElement,\n            removeNode: removeNode,\n            fragmentFromNodeChildren: fragmentFromNodeChildren,\n            createIterator: createIterator,\n            DomPosition: DomPosition\n        };\n\n        api.DOMException = DOMException;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Pure JavaScript implementation of DOM Range\n    api.createCoreModule("DomRange", ["DomUtil"], function(api, module) {\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DOMException = api.DOMException;\n\n        var isCharacterDataNode = dom.isCharacterDataNode;\n        var getNodeIndex = dom.getNodeIndex;\n        var isOrIsAncestorOf = dom.isOrIsAncestorOf;\n        var getDocument = dom.getDocument;\n        var comparePoints = dom.comparePoints;\n        var splitDataNode = dom.splitDataNode;\n        var getClosestAncestorIn = dom.getClosestAncestorIn;\n        var getNodeLength = dom.getNodeLength;\n        var arrayContains = dom.arrayContains;\n        var getRootContainer = dom.getRootContainer;\n        var crashyTextNodes = api.features.crashyTextNodes;\n\n        var removeNode = dom.removeNode;\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Utility functions\n\n        function isNonTextPartiallySelected(node, range) {\n            return (node.nodeType != 3) &&\n                   (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));\n        }\n\n        function getRangeDocument(range) {\n            return range.document || getDocument(range.startContainer);\n        }\n\n        function getRangeRoot(range) {\n            return getRootContainer(range.startContainer);\n        }\n\n        function getBoundaryBeforeNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node));\n        }\n\n        function getBoundaryAfterNode(node) {\n            return new DomPosition(node.parentNode, getNodeIndex(node) + 1);\n        }\n\n        function insertNodeAtPosition(node, n, o) {\n            var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n            if (isCharacterDataNode(n)) {\n                if (o == n.length) {\n                    dom.insertAfter(node, n);\n                } else {\n                    n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));\n                }\n            } else if (o >= n.childNodes.length) {\n                n.appendChild(node);\n            } else {\n                n.insertBefore(node, n.childNodes[o]);\n            }\n            return firstNodeInserted;\n        }\n\n        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {\n            assertRangeValid(rangeA);\n            assertRangeValid(rangeB);\n\n            if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {\n                throw new DOMException("WRONG_DOCUMENT_ERR");\n            }\n\n            var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset),\n                endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);\n\n            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n        }\n\n        function cloneSubtree(iterator) {\n            var partiallySelected;\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n                partiallySelected = iterator.isPartiallySelectedSubtree();\n                node = node.cloneNode(!partiallySelected);\n                if (partiallySelected) {\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(cloneSubtree(subIterator));\n                    subIterator.detach();\n                }\n\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException("HIERARCHY_REQUEST_ERR");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function iterateSubtree(rangeIterator, func, iteratorState) {\n            var it, n;\n            iteratorState = iteratorState || { stop: false };\n            for (var node, subRangeIterator; node = rangeIterator.next(); ) {\n                if (rangeIterator.isPartiallySelectedSubtree()) {\n                    if (func(node) === false) {\n                        iteratorState.stop = true;\n                        return;\n                    } else {\n                        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of\n                        // the node selected by the Range.\n                        subRangeIterator = rangeIterator.getSubtreeIterator();\n                        iterateSubtree(subRangeIterator, func, iteratorState);\n                        subRangeIterator.detach();\n                        if (iteratorState.stop) {\n                            return;\n                        }\n                    }\n                } else {\n                    // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n                    // descendants\n                    it = dom.createIterator(node);\n                    while ( (n = it.next()) ) {\n                        if (func(n) === false) {\n                            iteratorState.stop = true;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        function deleteSubtree(iterator) {\n            var subIterator;\n            while (iterator.next()) {\n                if (iterator.isPartiallySelectedSubtree()) {\n                    subIterator = iterator.getSubtreeIterator();\n                    deleteSubtree(subIterator);\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n            }\n        }\n\n        function extractSubtree(iterator) {\n            for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {\n\n                if (iterator.isPartiallySelectedSubtree()) {\n                    node = node.cloneNode(false);\n                    subIterator = iterator.getSubtreeIterator();\n                    node.appendChild(extractSubtree(subIterator));\n                    subIterator.detach();\n                } else {\n                    iterator.remove();\n                }\n                if (node.nodeType == 10) { // DocumentType\n                    throw new DOMException("HIERARCHY_REQUEST_ERR");\n                }\n                frag.appendChild(node);\n            }\n            return frag;\n        }\n\n        function getNodesInRange(range, nodeTypes, filter) {\n            var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;\n            var filterExists = !!filter;\n            if (filterNodeTypes) {\n                regex = new RegExp("^(" + nodeTypes.join("|") + ")$");\n            }\n\n            var nodes = [];\n            iterateSubtree(new RangeIterator(range, false), function(node) {\n                if (filterNodeTypes && !regex.test(node.nodeType)) {\n                    return;\n                }\n                if (filterExists && !filter(node)) {\n                    return;\n                }\n                // Don\'t include a boundary container if it is a character data node and the range does not contain any\n                // of its character data. See issue 190.\n                var sc = range.startContainer;\n                if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {\n                    return;\n                }\n\n                var ec = range.endContainer;\n                if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {\n                    return;\n                }\n\n                nodes.push(node);\n            });\n            return nodes;\n        }\n\n        function inspect(range) {\n            var name = (typeof range.getName == "undefined") ? "Range" : range.getName();\n            return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " +\n                    dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n        function RangeIterator(range, clonePartiallySelectedTextNodes) {\n            this.range = range;\n            this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n\n            if (!range.collapsed) {\n                this.sc = range.startContainer;\n                this.so = range.startOffset;\n                this.ec = range.endContainer;\n                this.eo = range.endOffset;\n                var root = range.commonAncestorContainer;\n\n                if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n                    this.isSingleCharacterDataNode = true;\n                    this._first = this._last = this._next = this.sc;\n                } else {\n                    this._first = this._next = (this.sc === root && !isCharacterDataNode(this.sc)) ?\n                        this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);\n                    this._last = (this.ec === root && !isCharacterDataNode(this.ec)) ?\n                        this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);\n                }\n            }\n        }\n\n        RangeIterator.prototype = {\n            _current: null,\n            _next: null,\n            _first: null,\n            _last: null,\n            isSingleCharacterDataNode: false,\n\n            reset: function() {\n                this._current = null;\n                this._next = this._first;\n            },\n\n            hasNext: function() {\n                return !!this._next;\n            },\n\n            next: function() {\n                // Move to next node\n                var current = this._current = this._next;\n                if (current) {\n                    this._next = (current !== this._last) ? current.nextSibling : null;\n\n                    // Check for partially selected text nodes\n                    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n                        if (current === this.ec) {\n                            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n                        }\n                        if (this._current === this.sc) {\n                            (current = current.cloneNode(true)).deleteData(0, this.so);\n                        }\n                    }\n                }\n\n                return current;\n            },\n\n            remove: function() {\n                var current = this._current, start, end;\n\n                if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n                    start = (current === this.sc) ? this.so : 0;\n                    end = (current === this.ec) ? this.eo : current.length;\n                    if (start != end) {\n                        current.deleteData(start, end - start);\n                    }\n                } else {\n                    if (current.parentNode) {\n                        removeNode(current);\n                    } else {\n                    }\n                }\n            },\n\n            // Checks if the current node is partially selected\n            isPartiallySelectedSubtree: function() {\n                var current = this._current;\n                return isNonTextPartiallySelected(current, this.range);\n            },\n\n            getSubtreeIterator: function() {\n                var subRange;\n                if (this.isSingleCharacterDataNode) {\n                    subRange = this.range.cloneRange();\n                    subRange.collapse(false);\n                } else {\n                    subRange = new Range(getRangeDocument(this.range));\n                    var current = this._current;\n                    var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n                    if (isOrIsAncestorOf(current, this.sc)) {\n                        startContainer = this.sc;\n                        startOffset = this.so;\n                    }\n                    if (isOrIsAncestorOf(current, this.ec)) {\n                        endContainer = this.ec;\n                        endOffset = this.eo;\n                    }\n\n                    updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n                }\n                return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n            },\n\n            detach: function() {\n                this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n            }\n        };\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n        var rootContainerNodeTypes = [2, 9, 11];\n        var readonlyNodeTypes = [5, 6, 10, 12];\n        var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n        var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n        function createAncestorFinder(nodeTypes) {\n            return function(node, selfIsAncestor) {\n                var t, n = selfIsAncestor ? node : node.parentNode;\n                while (n) {\n                    t = n.nodeType;\n                    if (arrayContains(nodeTypes, t)) {\n                        return n;\n                    }\n                    n = n.parentNode;\n                }\n                return null;\n            };\n        }\n\n        var getDocumentOrFragmentContainer = createAncestorFinder( [9, 11] );\n        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n        var getDocTypeNotationEntityAncestor = createAncestorFinder( [6, 10, 12] );\n\n        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n            if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n                throw new DOMException("INVALID_NODE_TYPE_ERR");\n            }\n        }\n\n        function assertValidNodeType(node, invalidTypes) {\n            if (!arrayContains(invalidTypes, node.nodeType)) {\n                throw new DOMException("INVALID_NODE_TYPE_ERR");\n            }\n        }\n\n        function assertValidOffset(node, offset) {\n            if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n                throw new DOMException("INDEX_SIZE_ERR");\n            }\n        }\n\n        function assertSameDocumentOrFragment(node1, node2) {\n            if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n                throw new DOMException("WRONG_DOCUMENT_ERR");\n            }\n        }\n\n        function assertNodeNotReadOnly(node) {\n            if (getReadonlyAncestor(node, true)) {\n                throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");\n            }\n        }\n\n        function assertNode(node, codeName) {\n            if (!node) {\n                throw new DOMException(codeName);\n            }\n        }\n\n        function isValidOffset(node, offset) {\n            return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);\n        }\n\n        function isRangeValid(range) {\n            return (!!range.startContainer && !!range.endContainer &&\n                    !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) &&\n                    getRootContainer(range.startContainer) == getRootContainer(range.endContainer) &&\n                    isValidOffset(range.startContainer, range.startOffset) &&\n                    isValidOffset(range.endContainer, range.endOffset));\n        }\n\n        function assertRangeValid(range) {\n            if (!isRangeValid(range)) {\n                throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range.inspect() + ")");\n            }\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Test the browser\'s innerHTML support to decide how to implement createContextualFragment\n        var styleEl = document.createElement("style");\n        var htmlParsingConforms = false;\n        try {\n            styleEl.innerHTML = "<b>x</b>";\n            htmlParsingConforms = (styleEl.firstChild.nodeType == 3); // Opera incorrectly creates an element node\n        } catch (e) {\n            // IE 6 and 7 throw\n        }\n\n        api.features.htmlParsingConforms = htmlParsingConforms;\n\n        var createContextualFragment = htmlParsingConforms ?\n\n            // Implementation as per HTML parsing spec, trusting in the browser\'s implementation of innerHTML. See\n            // discussion and base code for this implementation at issue 67.\n            // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n            // Thanks to Aleks Williams.\n            function(fragmentStr) {\n                // "Let node the context object\'s start\'s node."\n                var node = this.startContainer;\n                var doc = getDocument(node);\n\n                // "If the context object\'s start\'s node is null, raise an INVALID_STATE_ERR\n                // exception and abort these steps."\n                if (!node) {\n                    throw new DOMException("INVALID_STATE_ERR");\n                }\n\n                // "Let element be as follows, depending on node\'s interface:"\n                // Document, Document Fragment: null\n                var el = null;\n\n                // "Element: node"\n                if (node.nodeType == 1) {\n                    el = node;\n\n                // "Text, Comment: node\'s parentElement"\n                } else if (isCharacterDataNode(node)) {\n                    el = dom.parentElement(node);\n                }\n\n                // "If either element is null or element\'s ownerDocument is an HTML document\n                // and element\'s local name is "html" and element\'s namespace is the HTML\n                // namespace"\n                if (el === null || (\n                    el.nodeName == "HTML" &&\n                    dom.isHtmlNamespace(getDocument(el).documentElement) &&\n                    dom.isHtmlNamespace(el)\n                )) {\n\n                // "let element be a new Element with "body" as its local name and the HTML\n                // namespace as its namespace.""\n                    el = doc.createElement("body");\n                } else {\n                    el = el.cloneNode(false);\n                }\n\n                // "If the node\'s document is an HTML document: Invoke the HTML fragment parsing algorithm."\n                // "If the node\'s document is an XML document: Invoke the XML fragment parsing algorithm."\n                // "In either case, the algorithm must be invoked with fragment as the input\n                // and element as the context element."\n                el.innerHTML = fragmentStr;\n\n                // "If this raises an exception, then abort these steps. Otherwise, let new\n                // children be the nodes returned."\n\n                // "Let fragment be a new DocumentFragment."\n                // "Append all new children to fragment."\n                // "Return fragment."\n                return dom.fragmentFromNodeChildren(el);\n            } :\n\n            // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n            // previous versions of Rangy used (with the exception of using a body element rather than a div)\n            function(fragmentStr) {\n                var doc = getRangeDocument(this);\n                var el = doc.createElement("body");\n                el.innerHTML = fragmentStr;\n\n                return dom.fragmentFromNodeChildren(el);\n            };\n\n        function splitRangeBoundaries(range, positionsToPreserve) {\n            assertRangeValid(range);\n\n            var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;\n            var startEndSame = (sc === ec);\n\n            if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n                splitDataNode(ec, eo, positionsToPreserve);\n            }\n\n            if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n                sc = splitDataNode(sc, so, positionsToPreserve);\n                if (startEndSame) {\n                    eo -= so;\n                    ec = sc;\n                } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {\n                    eo++;\n                }\n                so = 0;\n            }\n            range.setStartAndEnd(sc, so, ec, eo);\n        }\n\n        function rangeToHtml(range) {\n            assertRangeValid(range);\n            var container = range.commonAncestorContainer.parentNode.cloneNode(false);\n            container.appendChild( range.cloneContents() );\n            return container.innerHTML;\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed",\n            "commonAncestorContainer"];\n\n        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;\n        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;\n\n        util.extend(api.rangePrototype, {\n            compareBoundaryPoints: function(how, range) {\n                assertRangeValid(this);\n                assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n                var nodeA, offsetA, nodeB, offsetB;\n                var prefixA = (how == e2s || how == s2s) ? "start" : "end";\n                var prefixB = (how == s2e || how == s2s) ? "start" : "end";\n                nodeA = this[prefixA + "Container"];\n                offsetA = this[prefixA + "Offset"];\n                nodeB = range[prefixB + "Container"];\n                offsetB = range[prefixB + "Offset"];\n                return comparePoints(nodeA, offsetA, nodeB, offsetB);\n            },\n\n            insertNode: function(node) {\n                assertRangeValid(this);\n                assertValidNodeType(node, insertableNodeTypes);\n                assertNodeNotReadOnly(this.startContainer);\n\n                if (isOrIsAncestorOf(node, this.startContainer)) {\n                    throw new DOMException("HIERARCHY_REQUEST_ERR");\n                }\n\n                // No check for whether the container of the start of the Range is of a type that does not allow\n                // children of the type of node: the browser\'s DOM implementation should do this for us when we attempt\n                // to add the node\n\n                var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                this.setStartBefore(firstNodeInserted);\n            },\n\n            cloneContents: function() {\n                assertRangeValid(this);\n\n                var clone, frag;\n                if (this.collapsed) {\n                    return getRangeDocument(this).createDocumentFragment();\n                } else {\n                    if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {\n                        clone = this.startContainer.cloneNode(true);\n                        clone.data = clone.data.slice(this.startOffset, this.endOffset);\n                        frag = getRangeDocument(this).createDocumentFragment();\n                        frag.appendChild(clone);\n                        return frag;\n                    } else {\n                        var iterator = new RangeIterator(this, true);\n                        clone = cloneSubtree(iterator);\n                        iterator.detach();\n                    }\n                    return clone;\n                }\n            },\n\n            canSurroundContents: function() {\n                assertRangeValid(this);\n                assertNodeNotReadOnly(this.startContainer);\n                assertNodeNotReadOnly(this.endContainer);\n\n                // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                // no non-text nodes.\n                var iterator = new RangeIterator(this, true);\n                var boundariesInvalid = (iterator._first && (isNonTextPartiallySelected(iterator._first, this)) ||\n                        (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                iterator.detach();\n                return !boundariesInvalid;\n            },\n\n            surroundContents: function(node) {\n                assertValidNodeType(node, surroundNodeTypes);\n\n                if (!this.canSurroundContents()) {\n                    throw new DOMException("INVALID_STATE_ERR");\n                }\n\n                // Extract the contents\n                var content = this.extractContents();\n\n                // Clear the children of the node\n                if (node.hasChildNodes()) {\n                    while (node.lastChild) {\n                        node.removeChild(node.lastChild);\n                    }\n                }\n\n                // Insert the new node and add the extracted contents\n                insertNodeAtPosition(node, this.startContainer, this.startOffset);\n                node.appendChild(content);\n\n                this.selectNode(node);\n            },\n\n            cloneRange: function() {\n                assertRangeValid(this);\n                var range = new Range(getRangeDocument(this));\n                var i = rangeProperties.length, prop;\n                while (i--) {\n                    prop = rangeProperties[i];\n                    range[prop] = this[prop];\n                }\n                return range;\n            },\n\n            toString: function() {\n                assertRangeValid(this);\n                var sc = this.startContainer;\n                if (sc === this.endContainer && isCharacterDataNode(sc)) {\n                    return (sc.nodeType == 3 || sc.nodeType == 4) ? sc.data.slice(this.startOffset, this.endOffset) : "";\n                } else {\n                    var textParts = [], iterator = new RangeIterator(this, true);\n                    iterateSubtree(iterator, function(node) {\n                        // Accept only text or CDATA nodes, not comments\n                        if (node.nodeType == 3 || node.nodeType == 4) {\n                            textParts.push(node.data);\n                        }\n                    });\n                    iterator.detach();\n                    return textParts.join("");\n                }\n            },\n\n            // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n            // been removed from Mozilla.\n\n            compareNode: function(node) {\n                assertRangeValid(this);\n\n                var parent = node.parentNode;\n                var nodeIndex = getNodeIndex(node);\n\n                if (!parent) {\n                    throw new DOMException("NOT_FOUND_ERR");\n                }\n\n                var startComparison = this.comparePoint(parent, nodeIndex),\n                    endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n                if (startComparison < 0) { // Node starts before\n                    return (endComparison > 0) ? n_b_a : n_b;\n                } else {\n                    return (endComparison > 0) ? n_a : n_i;\n                }\n            },\n\n            comparePoint: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, "HIERARCHY_REQUEST_ERR");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n                    return -1;\n                } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n                    return 1;\n                }\n                return 0;\n            },\n\n            createContextualFragment: createContextualFragment,\n\n            toHtml: function() {\n                return rangeToHtml(this);\n            },\n\n            // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n            // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n            intersectsNode: function(node, touchingIsIntersecting) {\n                assertRangeValid(this);\n                if (getRootContainer(node) != getRangeRoot(this)) {\n                    return false;\n                }\n\n                var parent = node.parentNode, offset = getNodeIndex(node);\n                if (!parent) {\n                    return true;\n                }\n\n                var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset),\n                    endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n                return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n            },\n\n            isPointInRange: function(node, offset) {\n                assertRangeValid(this);\n                assertNode(node, "HIERARCHY_REQUEST_ERR");\n                assertSameDocumentOrFragment(node, this.startContainer);\n\n                return (comparePoints(node, offset, this.startContainer, this.startOffset) >= 0) &&\n                       (comparePoints(node, offset, this.endContainer, this.endOffset) <= 0);\n            },\n\n            // The methods below are non-standard and invented by me.\n\n            // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n            intersectsRange: function(range) {\n                return rangesIntersect(this, range, false);\n            },\n\n            // Sharing a boundary start-to-end or end-to-start does count as intersection.\n            intersectsOrTouchesRange: function(range) {\n                return rangesIntersect(this, range, true);\n            },\n\n            intersection: function(range) {\n                if (this.intersectsRange(range)) {\n                    var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n                        endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n                    var intersectionRange = this.cloneRange();\n                    if (startComparison == -1) {\n                        intersectionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (endComparison == 1) {\n                        intersectionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return intersectionRange;\n                }\n                return null;\n            },\n\n            union: function(range) {\n                if (this.intersectsOrTouchesRange(range)) {\n                    var unionRange = this.cloneRange();\n                    if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n                        unionRange.setStart(range.startContainer, range.startOffset);\n                    }\n                    if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n                        unionRange.setEnd(range.endContainer, range.endOffset);\n                    }\n                    return unionRange;\n                } else {\n                    throw new DOMException("Ranges do not intersect");\n                }\n            },\n\n            containsNode: function(node, allowPartial) {\n                if (allowPartial) {\n                    return this.intersectsNode(node, false);\n                } else {\n                    return this.compareNode(node) == n_i;\n                }\n            },\n\n            containsNodeContents: function(node) {\n                return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;\n            },\n\n            containsRange: function(range) {\n                var intersection = this.intersection(range);\n                return intersection !== null && range.equals(intersection);\n            },\n\n            containsNodeText: function(node) {\n                var nodeRange = this.cloneRange();\n                nodeRange.selectNode(node);\n                var textNodes = nodeRange.getNodes([3]);\n                if (textNodes.length > 0) {\n                    nodeRange.setStart(textNodes[0], 0);\n                    var lastTextNode = textNodes.pop();\n                    nodeRange.setEnd(lastTextNode, lastTextNode.length);\n                    return this.containsRange(nodeRange);\n                } else {\n                    return this.containsNodeContents(node);\n                }\n            },\n\n            getNodes: function(nodeTypes, filter) {\n                assertRangeValid(this);\n                return getNodesInRange(this, nodeTypes, filter);\n            },\n\n            getDocument: function() {\n                return getRangeDocument(this);\n            },\n\n            collapseBefore: function(node) {\n                this.setEndBefore(node);\n                this.collapse(false);\n            },\n\n            collapseAfter: function(node) {\n                this.setStartAfter(node);\n                this.collapse(true);\n            },\n\n            getBookmark: function(containerNode) {\n                var doc = getRangeDocument(this);\n                var preSelectionRange = api.createRange(doc);\n                containerNode = containerNode || dom.getBody(doc);\n                preSelectionRange.selectNodeContents(containerNode);\n                var range = this.intersection(preSelectionRange);\n                var start = 0, end = 0;\n                if (range) {\n                    preSelectionRange.setEnd(range.startContainer, range.startOffset);\n                    start = preSelectionRange.toString().length;\n                    end = start + range.toString().length;\n                }\n\n                return {\n                    start: start,\n                    end: end,\n                    containerNode: containerNode\n                };\n            },\n\n            moveToBookmark: function(bookmark) {\n                var containerNode = bookmark.containerNode;\n                var charIndex = 0;\n                this.setStart(containerNode, 0);\n                this.collapse(true);\n                var nodeStack = [containerNode], node, foundStart = false, stop = false;\n                var nextCharIndex, i, childNodes;\n\n                while (!stop && (node = nodeStack.pop())) {\n                    if (node.nodeType == 3) {\n                        nextCharIndex = charIndex + node.length;\n                        if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {\n                            this.setStart(node, bookmark.start - charIndex);\n                            foundStart = true;\n                        }\n                        if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {\n                            this.setEnd(node, bookmark.end - charIndex);\n                            stop = true;\n                        }\n                        charIndex = nextCharIndex;\n                    } else {\n                        childNodes = node.childNodes;\n                        i = childNodes.length;\n                        while (i--) {\n                            nodeStack.push(childNodes[i]);\n                        }\n                    }\n                }\n            },\n\n            getName: function() {\n                return "DomRange";\n            },\n\n            equals: function(range) {\n                return Range.rangesEqual(this, range);\n            },\n\n            isValid: function() {\n                return isRangeValid(this);\n            },\n\n            inspect: function() {\n                return inspect(this);\n            },\n\n            detach: function() {\n                // In DOM4, detach() is now a no-op.\n            }\n        });\n\n        function copyComparisonConstantsToObject(obj) {\n            obj.START_TO_START = s2s;\n            obj.START_TO_END = s2e;\n            obj.END_TO_END = e2e;\n            obj.END_TO_START = e2s;\n\n            obj.NODE_BEFORE = n_b;\n            obj.NODE_AFTER = n_a;\n            obj.NODE_BEFORE_AND_AFTER = n_b_a;\n            obj.NODE_INSIDE = n_i;\n        }\n\n        function copyComparisonConstants(constructor) {\n            copyComparisonConstantsToObject(constructor);\n            copyComparisonConstantsToObject(constructor.prototype);\n        }\n\n        function createRangeContentRemover(remover, boundaryUpdater) {\n            return function() {\n                assertRangeValid(this);\n\n                var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;\n\n                var iterator = new RangeIterator(this, true);\n\n                // Work out where to position the range after content removal\n                var node, boundary;\n                if (sc !== root) {\n                    node = getClosestAncestorIn(sc, root, true);\n                    boundary = getBoundaryAfterNode(node);\n                    sc = boundary.node;\n                    so = boundary.offset;\n                }\n\n                // Check none of the range is read-only\n                iterateSubtree(iterator, assertNodeNotReadOnly);\n\n                iterator.reset();\n\n                // Remove the content\n                var returnValue = remover(iterator);\n                iterator.detach();\n\n                // Move to the new position\n                boundaryUpdater(this, sc, so, sc, so);\n\n                return returnValue;\n            };\n        }\n\n        function createPrototypeRange(constructor, boundaryUpdater) {\n            function createBeforeAfterNodeSetter(isBefore, isStart) {\n                return function(node) {\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n                    assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n                    var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n                    (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n                };\n            }\n\n            function setRangeStart(range, node, offset) {\n                var ec = range.endContainer, eo = range.endOffset;\n                if (node !== range.startContainer || offset !== range.startOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {\n                        ec = node;\n                        eo = offset;\n                    }\n                    boundaryUpdater(range, node, offset, ec, eo);\n                }\n            }\n\n            function setRangeEnd(range, node, offset) {\n                var sc = range.startContainer, so = range.startOffset;\n                if (node !== range.endContainer || offset !== range.endOffset) {\n                    // Check the root containers of the range and the new boundary, and also check whether the new boundary\n                    // is after the current end. In either case, collapse the range to the new position\n                    if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {\n                        sc = node;\n                        so = offset;\n                    }\n                    boundaryUpdater(range, sc, so, node, offset);\n                }\n            }\n\n            // Set up inheritance\n            var F = function() {};\n            F.prototype = api.rangePrototype;\n            constructor.prototype = new F();\n\n            util.extend(constructor.prototype, {\n                setStart: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeStart(this, node, offset);\n                },\n\n                setEnd: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n\n                    setRangeEnd(this, node, offset);\n                },\n\n                /**\n                 * Convenience method to set a range\'s start and end boundaries. Overloaded as follows:\n                 * - Two parameters (node, offset) creates a collapsed range at that position\n                 * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at\n                 *   startOffset and ending at endOffset\n                 * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in\n                 *   startNode and ending at endOffset in endNode\n                 */\n                setStartAndEnd: function() {\n                    var args = arguments;\n                    var sc = args[0], so = args[1], ec = sc, eo = so;\n\n                    switch (args.length) {\n                        case 3:\n                            eo = args[2];\n                            break;\n                        case 4:\n                            ec = args[2];\n                            eo = args[3];\n                            break;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                setBoundary: function(node, offset, isStart) {\n                    this["set" + (isStart ? "Start" : "End")](node, offset);\n                },\n\n                setStartBefore: createBeforeAfterNodeSetter(true, true),\n                setStartAfter: createBeforeAfterNodeSetter(false, true),\n                setEndBefore: createBeforeAfterNodeSetter(true, false),\n                setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n                collapse: function(isStart) {\n                    assertRangeValid(this);\n                    if (isStart) {\n                        boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n                    } else {\n                        boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n                    }\n                },\n\n                selectNodeContents: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n\n                    boundaryUpdater(this, node, 0, node, getNodeLength(node));\n                },\n\n                selectNode: function(node) {\n                    assertNoDocTypeNotationEntityAncestor(node, false);\n                    assertValidNodeType(node, beforeAfterNodeTypes);\n\n                    var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);\n                    boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n                },\n\n                extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n                deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n                canSurroundContents: function() {\n                    assertRangeValid(this);\n                    assertNodeNotReadOnly(this.startContainer);\n                    assertNodeNotReadOnly(this.endContainer);\n\n                    // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n                    // no non-text nodes.\n                    var iterator = new RangeIterator(this, true);\n                    var boundariesInvalid = (iterator._first && isNonTextPartiallySelected(iterator._first, this) ||\n                            (iterator._last && isNonTextPartiallySelected(iterator._last, this)));\n                    iterator.detach();\n                    return !boundariesInvalid;\n                },\n\n                splitBoundaries: function() {\n                    splitRangeBoundaries(this);\n                },\n\n                splitBoundariesPreservingPositions: function(positionsToPreserve) {\n                    splitRangeBoundaries(this, positionsToPreserve);\n                },\n\n                normalizeBoundaries: function() {\n                    assertRangeValid(this);\n\n                    var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;\n\n                    var mergeForward = function(node) {\n                        var sibling = node.nextSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            ec = node;\n                            eo = node.length;\n                            node.appendData(sibling.data);\n                            removeNode(sibling);\n                        }\n                    };\n\n                    var mergeBackward = function(node) {\n                        var sibling = node.previousSibling;\n                        if (sibling && sibling.nodeType == node.nodeType) {\n                            sc = node;\n                            var nodeLength = node.length;\n                            so = sibling.length;\n                            node.insertData(0, sibling.data);\n                            removeNode(sibling);\n                            if (sc == ec) {\n                                eo += so;\n                                ec = sc;\n                            } else if (ec == node.parentNode) {\n                                var nodeIndex = getNodeIndex(node);\n                                if (eo == nodeIndex) {\n                                    ec = node;\n                                    eo = nodeLength;\n                                } else if (eo > nodeIndex) {\n                                    eo--;\n                                }\n                            }\n                        }\n                    };\n\n                    var normalizeStart = true;\n                    var sibling;\n\n                    if (isCharacterDataNode(ec)) {\n                        if (eo == ec.length) {\n                            mergeForward(ec);\n                        } else if (eo == 0) {\n                            sibling = ec.previousSibling;\n                            if (sibling && sibling.nodeType == ec.nodeType) {\n                                eo = sibling.length;\n                                if (sc == ec) {\n                                    normalizeStart = false;\n                                }\n                                sibling.appendData(ec.data);\n                                removeNode(ec);\n                                ec = sibling;\n                            }\n                        }\n                    } else {\n                        if (eo > 0) {\n                            var endNode = ec.childNodes[eo - 1];\n                            if (endNode && isCharacterDataNode(endNode)) {\n                                mergeForward(endNode);\n                            }\n                        }\n                        normalizeStart = !this.collapsed;\n                    }\n\n                    if (normalizeStart) {\n                        if (isCharacterDataNode(sc)) {\n                            if (so == 0) {\n                                mergeBackward(sc);\n                            } else if (so == sc.length) {\n                                sibling = sc.nextSibling;\n                                if (sibling && sibling.nodeType == sc.nodeType) {\n                                    if (ec == sibling) {\n                                        ec = sc;\n                                        eo += sc.length;\n                                    }\n                                    sc.appendData(sibling.data);\n                                    removeNode(sibling);\n                                }\n                            }\n                        } else {\n                            if (so < sc.childNodes.length) {\n                                var startNode = sc.childNodes[so];\n                                if (startNode && isCharacterDataNode(startNode)) {\n                                    mergeBackward(startNode);\n                                }\n                            }\n                        }\n                    } else {\n                        sc = ec;\n                        so = eo;\n                    }\n\n                    boundaryUpdater(this, sc, so, ec, eo);\n                },\n\n                collapseToPoint: function(node, offset) {\n                    assertNoDocTypeNotationEntityAncestor(node, true);\n                    assertValidOffset(node, offset);\n                    this.setStartAndEnd(node, offset);\n                }\n            });\n\n            copyComparisonConstants(constructor);\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Updates commonAncestorContainer and collapsed after boundary change\n        function updateCollapsedAndCommonAncestor(range) {\n            range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n            range.commonAncestorContainer = range.collapsed ?\n                range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n        }\n\n        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n            range.startContainer = startContainer;\n            range.startOffset = startOffset;\n            range.endContainer = endContainer;\n            range.endOffset = endOffset;\n            range.document = dom.getDocument(startContainer);\n\n            updateCollapsedAndCommonAncestor(range);\n        }\n\n        function Range(doc) {\n            this.startContainer = doc;\n            this.startOffset = 0;\n            this.endContainer = doc;\n            this.endOffset = 0;\n            this.document = doc;\n            updateCollapsedAndCommonAncestor(this);\n        }\n\n        createPrototypeRange(Range, updateBoundaries);\n\n        util.extend(Range, {\n            rangeProperties: rangeProperties,\n            RangeIterator: RangeIterator,\n            copyComparisonConstants: copyComparisonConstants,\n            createPrototypeRange: createPrototypeRange,\n            inspect: inspect,\n            toHtml: rangeToHtml,\n            getRangeDocument: getRangeDocument,\n            rangesEqual: function(r1, r2) {\n                return r1.startContainer === r2.startContainer &&\n                    r1.startOffset === r2.startOffset &&\n                    r1.endContainer === r2.endContainer &&\n                    r1.endOffset === r2.endOffset;\n            }\n        });\n\n        api.DomRange = Range;\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wrappers for the browser\'s native DOM Range and/or TextRange implementation\n    api.createCoreModule("WrappedRange", ["DomRange"], function(api, module) {\n        var WrappedRange, WrappedTextRange;\n        var dom = api.dom;\n        var util = api.util;\n        var DomPosition = dom.DomPosition;\n        var DomRange = api.DomRange;\n        var getBody = dom.getBody;\n        var getContentDocument = dom.getContentDocument;\n        var isCharacterDataNode = dom.isCharacterDataNode;\n\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        if (api.features.implementsDomRange) {\n            // This is a wrapper around the browser\'s native DOM Range. It has two aims:\n            // - Provide workarounds for specific browser bugs\n            // - provide convenient extensions, which are inherited from Rangy\'s DomRange\n\n            (function() {\n                var rangeProto;\n                var rangeProperties = DomRange.rangeProperties;\n\n                function updateRangeProperties(range) {\n                    var i = rangeProperties.length, prop;\n                    while (i--) {\n                        prop = rangeProperties[i];\n                        range[prop] = range.nativeRange[prop];\n                    }\n                    // Fix for broken collapsed property in IE 9.\n                    range.collapsed = (range.startContainer === range.endContainer && range.startOffset === range.endOffset);\n                }\n\n                function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n                    var startMoved = (range.startContainer !== startContainer || range.startOffset != startOffset);\n                    var endMoved = (range.endContainer !== endContainer || range.endOffset != endOffset);\n                    var nativeRangeDifferent = !range.equals(range.nativeRange);\n\n                    // Always set both boundaries for the benefit of IE9 (see issue 35)\n                    if (startMoved || endMoved || nativeRangeDifferent) {\n                        range.setEnd(endContainer, endOffset);\n                        range.setStart(startContainer, startOffset);\n                    }\n                }\n\n                var createBeforeAfterNodeSetter;\n\n                WrappedRange = function(range) {\n                    if (!range) {\n                        throw module.createError("WrappedRange: Range must be specified");\n                    }\n                    this.nativeRange = range;\n                    updateRangeProperties(this);\n                };\n\n                DomRange.createPrototypeRange(WrappedRange, updateNativeRange);\n\n                rangeProto = WrappedRange.prototype;\n\n                rangeProto.selectNode = function(node) {\n                    this.nativeRange.selectNode(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneContents = function() {\n                    return this.nativeRange.cloneContents();\n                };\n\n                // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,\n                // insertNode() is never delegated to the native range.\n\n                rangeProto.surroundContents = function(node) {\n                    this.nativeRange.surroundContents(node);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.collapse = function(isStart) {\n                    this.nativeRange.collapse(isStart);\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.cloneRange = function() {\n                    return new WrappedRange(this.nativeRange.cloneRange());\n                };\n\n                rangeProto.refresh = function() {\n                    updateRangeProperties(this);\n                };\n\n                rangeProto.toString = function() {\n                    return this.nativeRange.toString();\n                };\n\n                // Create test range and node for feature detection\n\n                var testTextNode = document.createTextNode("test");\n                getBody(document).appendChild(testTextNode);\n                var range = document.createRange();\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n                // correct for it\n\n                range.setStart(testTextNode, 0);\n                range.setEnd(testTextNode, 0);\n\n                try {\n                    range.setStart(testTextNode, 1);\n\n                    rangeProto.setStart = function(node, offset) {\n                        this.nativeRange.setStart(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        this.nativeRange.setEnd(node, offset);\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name) {\n                        return function(node) {\n                            this.nativeRange[name](node);\n                            updateRangeProperties(this);\n                        };\n                    };\n\n                } catch(ex) {\n\n                    rangeProto.setStart = function(node, offset) {\n                        try {\n                            this.nativeRange.setStart(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setEnd(node, offset);\n                            this.nativeRange.setStart(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.setEnd = function(node, offset) {\n                        try {\n                            this.nativeRange.setEnd(node, offset);\n                        } catch (ex) {\n                            this.nativeRange.setStart(node, offset);\n                            this.nativeRange.setEnd(node, offset);\n                        }\n                        updateRangeProperties(this);\n                    };\n\n                    createBeforeAfterNodeSetter = function(name, oppositeName) {\n                        return function(node) {\n                            try {\n                                this.nativeRange[name](node);\n                            } catch (ex) {\n                                this.nativeRange[oppositeName](node);\n                                this.nativeRange[name](node);\n                            }\n                            updateRangeProperties(this);\n                        };\n                    };\n                }\n\n                rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");\n                rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");\n                rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");\n                rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Always use DOM4-compliant selectNodeContents implementation: it\'s simpler and less code than testing\n                // whether the native implementation can be trusted\n                rangeProto.selectNodeContents = function(node) {\n                    this.setStartAndEnd(node, 0, dom.getNodeLength(node));\n                };\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for\n                // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n                range.selectNodeContents(testTextNode);\n                range.setEnd(testTextNode, 3);\n\n                var range2 = document.createRange();\n                range2.selectNodeContents(testTextNode);\n                range2.setEnd(testTextNode, 4);\n                range2.setStart(testTextNode, 2);\n\n                if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 &&\n                        range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n                    // This is the wrong way round, so correct for it\n\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        range = range.nativeRange || range;\n                        if (type == range.START_TO_END) {\n                            type = range.END_TO_START;\n                        } else if (type == range.END_TO_START) {\n                            type = range.START_TO_END;\n                        }\n                        return this.nativeRange.compareBoundaryPoints(type, range);\n                    };\n                } else {\n                    rangeProto.compareBoundaryPoints = function(type, range) {\n                        return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.\n\n                var el = document.createElement("div");\n                el.innerHTML = "123";\n                var textNode = el.firstChild;\n                var body = getBody(document);\n                body.appendChild(el);\n\n                range.setStart(textNode, 1);\n                range.setEnd(textNode, 2);\n                range.deleteContents();\n\n                if (textNode.data == "13") {\n                    // Behaviour is correct per DOM4 Range so wrap the browser\'s implementation of deleteContents() and\n                    // extractContents()\n                    rangeProto.deleteContents = function() {\n                        this.nativeRange.deleteContents();\n                        updateRangeProperties(this);\n                    };\n\n                    rangeProto.extractContents = function() {\n                        var frag = this.nativeRange.extractContents();\n                        updateRangeProperties(this);\n                        return frag;\n                    };\n                } else {\n                }\n\n                body.removeChild(el);\n                body = null;\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Test for existence of createContextualFragment and delegate to it if it exists\n                if (util.isHostMethod(range, "createContextualFragment")) {\n                    rangeProto.createContextualFragment = function(fragmentStr) {\n                        return this.nativeRange.createContextualFragment(fragmentStr);\n                    };\n                }\n\n                /*--------------------------------------------------------------------------------------------------------*/\n\n                // Clean up\n                getBody(document).removeChild(testTextNode);\n\n                rangeProto.getName = function() {\n                    return "WrappedRange";\n                };\n\n                api.WrappedRange = WrappedRange;\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, "createNativeRange");\n                    return doc.createRange();\n                };\n            })();\n        }\n\n        if (api.features.implementsTextRange) {\n            /*\n            This is a workaround for a bug where IE returns the wrong container element from the TextRange\'s parentElement()\n            method. For example, in the following (where pipes denote the selection boundaries):\n\n            <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>\n\n            var range = document.selection.createRange();\n            alert(range.parentElement().id); // Should alert "ul" but alerts "b"\n\n            This method returns the common ancestor node of the following:\n            - the parentElement() of the textRange\n            - the parentElement() of the textRange after calling collapse(true)\n            - the parentElement() of the textRange after calling collapse(false)\n            */\n            var getTextRangeContainerElement = function(textRange) {\n                var parentEl = textRange.parentElement();\n                var range = textRange.duplicate();\n                range.collapse(true);\n                var startEl = range.parentElement();\n                range = textRange.duplicate();\n                range.collapse(false);\n                var endEl = range.parentElement();\n                var startEndContainer = (startEl == endEl) ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n                return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n            };\n\n            var textRangeIsCollapsed = function(textRange) {\n                return textRange.compareEndPoints("StartToEnd", textRange) == 0;\n            };\n\n            // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started\n            // out as an improved version of code found in Tim Cameron Ryan\'s IERange (http://code.google.com/p/ierange/)\n            // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange\n            // bugs, handling for inputs and images, plus optimizations.\n            var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {\n                var workingRange = textRange.duplicate();\n                workingRange.collapse(isStart);\n                var containerElement = workingRange.parentElement();\n\n                // Sometimes collapsing a TextRange that\'s at the start of a text node can move it into the previous node, so\n                // check for that\n                if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {\n                    containerElement = wholeRangeContainerElement;\n                }\n\n\n                // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and\n                // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n                if (!containerElement.canHaveHTML) {\n                    var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n                    return {\n                        boundaryPosition: pos,\n                        nodeInfo: {\n                            nodeIndex: pos.offset,\n                            containerElement: pos.node\n                        }\n                    };\n                }\n\n                var workingNode = dom.getDocument(containerElement).createElement("span");\n\n                // Workaround for HTML5 Shiv\'s insane violation of document.createElement(). See Rangy issue 104 and HTML5\n                // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64\n                if (workingNode.parentNode) {\n                    dom.removeNode(workingNode);\n                }\n\n                var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";\n                var previousNode, nextNode, boundaryPosition, boundaryNode;\n                var start = (startInfo && startInfo.containerElement == containerElement) ? startInfo.nodeIndex : 0;\n                var childNodeCount = containerElement.childNodes.length;\n                var end = childNodeCount;\n\n                // Check end first. Code within the loop assumes that the endth child node of the container is definitely\n                // after the range boundary.\n                var nodeIndex = end;\n\n                while (true) {\n                    if (nodeIndex == childNodeCount) {\n                        containerElement.appendChild(workingNode);\n                    } else {\n                        containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);\n                    }\n                    workingRange.moveToElementText(workingNode);\n                    comparison = workingRange.compareEndPoints(workingComparisonType, textRange);\n                    if (comparison == 0 || start == end) {\n                        break;\n                    } else if (comparison == -1) {\n                        if (end == start + 1) {\n                            // We know the endth child node is after the range boundary, so we must be done.\n                            break;\n                        } else {\n                            start = nodeIndex;\n                        }\n                    } else {\n                        end = (end == start + 1) ? start : nodeIndex;\n                    }\n                    nodeIndex = Math.floor((start + end) / 2);\n                    containerElement.removeChild(workingNode);\n                }\n\n\n                // We\'ve now reached or gone past the boundary of the text range we\'re interested in\n                // so have identified the node we want\n                boundaryNode = workingNode.nextSibling;\n\n                if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {\n                    // This is a character data node (text, comment, cdata). The working range is collapsed at the start of\n                    // the node containing the text range\'s boundary, so we move the end of the working range to the\n                    // boundary point and measure the length of its text to get the boundary\'s offset within the node.\n                    workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);\n\n                    var offset;\n\n                    if (/[\\r\\n]/.test(boundaryNode.data)) {\n                        /*\n                        For the particular case of a boundary within a text node containing rendered line breaks (within a\n                        <pre> element, for example), we need a slightly complicated approach to get the boundary\'s offset in\n                        IE. The facts:\n\n                        - Each line break is represented as \\r in the text node\'s data/nodeValue properties\n                        - Each line break is represented as \\r\\n in the TextRange\'s \'text\' property\n                        - The \'text\' property of the TextRange does not contain trailing line breaks\n\n                        To get round the problem presented by the final fact above, we can use the fact that TextRange\'s\n                        moveStart() and moveEnd() methods return the actual number of characters moved, which is not\n                        necessarily the same as the number of characters it was instructed to move. The simplest approach is\n                        to use this to store the characters moved when moving both the start and end of the range to the\n                        start of the document body and subtracting the start offset from the end offset (the\n                        "move-negative-gazillion" method). However, this is extremely slow when the document is large and\n                        the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to\n                        the end of the document) has the same problem.\n\n                        Another approach that works is to use moveStart() to move the start boundary of the range up to the\n                        end boundary one character at a time and incrementing a counter with the value returned by the\n                        moveStart() call. However, the check for whether the start boundary has reached the end boundary is\n                        expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected\n                        by the location of the range within the document).\n\n                        The approach used below is a hybrid of the two methods above. It uses the fact that a string\n                        containing the TextRange\'s \'text\' property with each \\r\\n converted to a single \\r character cannot\n                        be longer than the text of the TextRange, so the start of the range is moved that length initially\n                        and then a character at a time to make up for any trailing line breaks not contained in the \'text\'\n                        property. This has good performance in most situations compared to the previous two methods.\n                        */\n                        var tempRange = workingRange.duplicate();\n                        var rangeLength = tempRange.text.replace(/\\r\\n/g, "\\r").length;\n\n                        offset = tempRange.moveStart("character", rangeLength);\n                        while ( (comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {\n                            offset++;\n                            tempRange.moveStart("character", 1);\n                        }\n                    } else {\n                        offset = workingRange.text.length;\n                    }\n                    boundaryPosition = new DomPosition(boundaryNode, offset);\n                } else {\n\n                    // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n                    // a position within that, and likewise for a start boundary preceding a character data node\n                    previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n                    nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n                    if (nextNode && isCharacterDataNode(nextNode)) {\n                        boundaryPosition = new DomPosition(nextNode, 0);\n                    } else if (previousNode && isCharacterDataNode(previousNode)) {\n                        boundaryPosition = new DomPosition(previousNode, previousNode.data.length);\n                    } else {\n                        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n                    }\n                }\n\n                // Clean up\n                dom.removeNode(workingNode);\n\n                return {\n                    boundaryPosition: boundaryPosition,\n                    nodeInfo: {\n                        nodeIndex: nodeIndex,\n                        containerElement: containerElement\n                    }\n                };\n            };\n\n            // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that\n            // node. This function started out as an optimized version of code found in Tim Cameron Ryan\'s IERange\n            // (http://code.google.com/p/ierange/)\n            var createBoundaryTextRange = function(boundaryPosition, isStart) {\n                var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;\n                var doc = dom.getDocument(boundaryPosition.node);\n                var workingNode, childNodes, workingRange = getBody(doc).createTextRange();\n                var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);\n\n                if (nodeIsDataNode) {\n                    boundaryNode = boundaryPosition.node;\n                    boundaryParent = boundaryNode.parentNode;\n                } else {\n                    childNodes = boundaryPosition.node.childNodes;\n                    boundaryNode = (boundaryOffset < childNodes.length) ? childNodes[boundaryOffset] : null;\n                    boundaryParent = boundaryPosition.node;\n                }\n\n                // Position the range immediately before the node containing the boundary\n                workingNode = doc.createElement("span");\n\n                // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within\n                // the element rather than immediately before or after it\n                workingNode.innerHTML = "&#feff;";\n\n                // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n                // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n                if (boundaryNode) {\n                    boundaryParent.insertBefore(workingNode, boundaryNode);\n                } else {\n                    boundaryParent.appendChild(workingNode);\n                }\n\n                workingRange.moveToElementText(workingNode);\n                workingRange.collapse(!isStart);\n\n                // Clean up\n                boundaryParent.removeChild(workingNode);\n\n                // Move the working range to the text offset, if required\n                if (nodeIsDataNode) {\n                    workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);\n                }\n\n                return workingRange;\n            };\n\n            /*------------------------------------------------------------------------------------------------------------*/\n\n            // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy\'s DomRange as a\n            // prototype\n\n            WrappedTextRange = function(textRange) {\n                this.textRange = textRange;\n                this.refresh();\n            };\n\n            WrappedTextRange.prototype = new DomRange(document);\n\n            WrappedTextRange.prototype.refresh = function() {\n                var start, end, startBoundary;\n\n                // TextRange\'s parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n                var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n                if (textRangeIsCollapsed(this.textRange)) {\n                    end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true,\n                        true).boundaryPosition;\n                } else {\n                    startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n                    start = startBoundary.boundaryPosition;\n\n                    // An optimization used here is that if the start and end boundaries have the same parent element, the\n                    // search scope for the end boundary can be limited to exclude the portion of the element that precedes\n                    // the start boundary\n                    end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false,\n                        startBoundary.nodeInfo).boundaryPosition;\n                }\n\n                this.setStart(start.node, start.offset);\n                this.setEnd(end.node, end.offset);\n            };\n\n            WrappedTextRange.prototype.getName = function() {\n                return "WrappedTextRange";\n            };\n\n            DomRange.copyComparisonConstants(WrappedTextRange);\n\n            var rangeToTextRange = function(range) {\n                if (range.collapsed) {\n                    return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                } else {\n                    var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n                    var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n                    var textRange = getBody( DomRange.getRangeDocument(range) ).createTextRange();\n                    textRange.setEndPoint("StartToStart", startRange);\n                    textRange.setEndPoint("EndToEnd", endRange);\n                    return textRange;\n                }\n            };\n\n            WrappedTextRange.rangeToTextRange = rangeToTextRange;\n\n            WrappedTextRange.prototype.toTextRange = function() {\n                return rangeToTextRange(this);\n            };\n\n            api.WrappedTextRange = WrappedTextRange;\n\n            // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which\n            // implementation to use by default.\n            if (!api.features.implementsDomRange || api.config.preferTextRange) {\n                // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n                var globalObj = (function(f) { return f("return this;")(); })(Function);\n                if (typeof globalObj.Range == "undefined") {\n                    globalObj.Range = WrappedTextRange;\n                }\n\n                api.createNativeRange = function(doc) {\n                    doc = getContentDocument(doc, module, "createNativeRange");\n                    return getBody(doc).createTextRange();\n                };\n\n                api.WrappedRange = WrappedTextRange;\n            }\n        }\n\n        api.createRange = function(doc) {\n            doc = getContentDocument(doc, module, "createRange");\n            return new api.WrappedRange(api.createNativeRange(doc));\n        };\n\n        api.createRangyRange = function(doc) {\n            doc = getContentDocument(doc, module, "createRangyRange");\n            return new DomRange(doc);\n        };\n\n        util.createAliasForDeprecatedMethod(api, "createIframeRange", "createRange");\n        util.createAliasForDeprecatedMethod(api, "createIframeRangyRange", "createRangyRange");\n\n        api.addShimListener(function(win) {\n            var doc = win.document;\n            if (typeof doc.createRange == "undefined") {\n                doc.createRange = function() {\n                    return api.createRange(doc);\n                };\n            }\n            doc = win = null;\n        });\n    });\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification\n    // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)\n    api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api, module) {\n        api.config.checkSelectionRanges = true;\n\n        var BOOLEAN = "boolean";\n        var NUMBER = "number";\n        var dom = api.dom;\n        var util = api.util;\n        var isHostMethod = util.isHostMethod;\n        var DomRange = api.DomRange;\n        var WrappedRange = api.WrappedRange;\n        var DOMException = api.DOMException;\n        var DomPosition = dom.DomPosition;\n        var getNativeSelection;\n        var selectionIsCollapsed;\n        var features = api.features;\n        var CONTROL = "Control";\n        var getDocument = dom.getDocument;\n        var getBody = dom.getBody;\n        var rangesEqual = DomRange.rangesEqual;\n\n\n        // Utility function to support direction parameters in the API that may be a string ("backward", "backwards",\n        // "forward" or "forwards") or a Boolean (true for backwards).\n        function isDirectionBackward(dir) {\n            return (typeof dir == "string") ? /^backward(s)?$/i.test(dir) : !!dir;\n        }\n\n        function getWindow(win, methodName) {\n            if (!win) {\n                return window;\n            } else if (dom.isWindow(win)) {\n                return win;\n            } else if (win instanceof WrappedSelection) {\n                return win.win;\n            } else {\n                var doc = dom.getContentDocument(win, module, methodName);\n                return dom.getWindow(doc);\n            }\n        }\n\n        function getWinSelection(winParam) {\n            return getWindow(winParam, "getWinSelection").getSelection();\n        }\n\n        function getDocSelection(winParam) {\n            return getWindow(winParam, "getDocSelection").document.selection;\n        }\n\n        function winSelectionIsBackward(sel) {\n            var backward = false;\n            if (sel.anchorNode) {\n                backward = (dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1);\n            }\n            return backward;\n        }\n\n        // Test for the Range/TextRange and Selection features required\n        // Test for ability to retrieve selection\n        var implementsWinGetSelection = isHostMethod(window, "getSelection"),\n            implementsDocSelection = util.isHostObject(document, "selection");\n\n        features.implementsWinGetSelection = implementsWinGetSelection;\n        features.implementsDocSelection = implementsDocSelection;\n\n        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n        if (useDocumentSelection) {\n            getNativeSelection = getDocSelection;\n            api.isSelectionValid = function(winParam) {\n                var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;\n\n                // Check whether the selection TextRange is actually contained within the correct document\n                return (nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc);\n            };\n        } else if (implementsWinGetSelection) {\n            getNativeSelection = getWinSelection;\n            api.isSelectionValid = function() {\n                return true;\n            };\n        } else {\n            module.fail("Neither document.selection or window.getSelection() detected.");\n            return false;\n        }\n\n        api.getNativeSelection = getNativeSelection;\n\n        var testSelection = getNativeSelection();\n\n        // In Firefox, the selection is null in an iframe with display: none. See issue #138.\n        if (!testSelection) {\n            module.fail("Native selection was null (possibly issue 138?)");\n            return false;\n        }\n\n        var testRange = api.createNativeRange(document);\n        var body = getBody(document);\n\n        // Obtaining a range from a selection\n        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection,\n            ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);\n\n        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n        // Test for existence of native selection extend() method\n        var selectionHasExtend = isHostMethod(testSelection, "extend");\n        features.selectionHasExtend = selectionHasExtend;\n\n        // Test if rangeCount exists\n        var selectionHasRangeCount = (typeof testSelection.rangeCount == NUMBER);\n        features.selectionHasRangeCount = selectionHasRangeCount;\n\n        var selectionSupportsMultipleRanges = false;\n        var collapsedNonEditableSelectionsSupported = true;\n\n        var addRangeBackwardToNative = selectionHasExtend ?\n            function(nativeSelection, range) {\n                var doc = DomRange.getRangeDocument(range);\n                var endRange = api.createRange(doc);\n                endRange.collapseToPoint(range.endContainer, range.endOffset);\n                nativeSelection.addRange(getNativeRange(endRange));\n                nativeSelection.extend(range.startContainer, range.startOffset);\n            } : null;\n\n        if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) &&\n                typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {\n\n            (function() {\n                // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are\n                // performed on the current document\'s selection. See issue 109.\n\n                // Note also that if a selection previously existed, it is wiped and later restored by these tests. This\n                // will result in the selection direction begin reversed if the original selection was backwards and the\n                // browser does not support setting backwards selections (Internet Explorer, I\'m looking at you).\n                var sel = window.getSelection();\n                if (sel) {\n                    // Store the current selection\n                    var originalSelectionRangeCount = sel.rangeCount;\n                    var selectionHasMultipleRanges = (originalSelectionRangeCount > 1);\n                    var originalSelectionRanges = [];\n                    var originalSelectionBackward = winSelectionIsBackward(sel);\n                    for (var i = 0; i < originalSelectionRangeCount; ++i) {\n                        originalSelectionRanges[i] = sel.getRangeAt(i);\n                    }\n\n                    // Create some test elements\n                    var testEl = dom.createTestElement(document, "", false);\n                    var textNode = testEl.appendChild( document.createTextNode("\\u00a0\\u00a0\\u00a0") );\n\n                    // Test whether the native selection will allow a collapsed selection within a non-editable element\n                    var r1 = document.createRange();\n\n                    r1.setStart(textNode, 1);\n                    r1.collapse(true);\n                    sel.removeAllRanges();\n                    sel.addRange(r1);\n                    collapsedNonEditableSelectionsSupported = (sel.rangeCount == 1);\n                    sel.removeAllRanges();\n\n                    // Test whether the native selection is capable of supporting multiple ranges.\n                    if (!selectionHasMultipleRanges) {\n                        // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a\n                        // console error of "Discontiguous selection is not supported." that cannot be suppressed. There\'s\n                        // nothing we can do about this while retaining the feature test so we have to resort to a browser\n                        // sniff. I\'m not happy about it. See\n                        // https://code.google.com/p/chromium/issues/detail?id=399791\n                        var chromeMatch = window.navigator.appVersion.match(/Chrome\\/(.*?) /);\n                        if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {\n                            selectionSupportsMultipleRanges = false;\n                        } else {\n                            var r2 = r1.cloneRange();\n                            r1.setStart(textNode, 0);\n                            r2.setEnd(textNode, 3);\n                            r2.setStart(textNode, 2);\n                            sel.addRange(r1);\n                            sel.addRange(r2);\n                            selectionSupportsMultipleRanges = (sel.rangeCount == 2);\n                        }\n                    }\n\n                    // Clean up\n                    dom.removeNode(testEl);\n                    sel.removeAllRanges();\n\n                    for (i = 0; i < originalSelectionRangeCount; ++i) {\n                        if (i == 0 && originalSelectionBackward) {\n                            if (addRangeBackwardToNative) {\n                                addRangeBackwardToNative(sel, originalSelectionRanges[i]);\n                            } else {\n                                api.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");\n                                sel.addRange(originalSelectionRanges[i]);\n                            }\n                        } else {\n                            sel.addRange(originalSelectionRanges[i]);\n                        }\n                    }\n                }\n            })();\n        }\n\n        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n        // ControlRanges\n        var implementsControlRange = false, testControlRange;\n\n        if (body && isHostMethod(body, "createControlRange")) {\n            testControlRange = body.createControlRange();\n            if (util.areHostProperties(testControlRange, ["item", "add"])) {\n                implementsControlRange = true;\n            }\n        }\n        features.implementsControlRange = implementsControlRange;\n\n        // Selection collapsedness\n        if (selectionHasAnchorAndFocus) {\n            selectionIsCollapsed = function(sel) {\n                return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n            };\n        } else {\n            selectionIsCollapsed = function(sel) {\n                return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n            };\n        }\n\n        function updateAnchorAndFocusFromRange(sel, range, backward) {\n            var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";\n            sel.anchorNode = range[anchorPrefix + "Container"];\n            sel.anchorOffset = range[anchorPrefix + "Offset"];\n            sel.focusNode = range[focusPrefix + "Container"];\n            sel.focusOffset = range[focusPrefix + "Offset"];\n        }\n\n        function updateAnchorAndFocusFromNativeSelection(sel) {\n            var nativeSel = sel.nativeSelection;\n            sel.anchorNode = nativeSel.anchorNode;\n            sel.anchorOffset = nativeSel.anchorOffset;\n            sel.focusNode = nativeSel.focusNode;\n            sel.focusOffset = nativeSel.focusOffset;\n        }\n\n        function updateEmptySelection(sel) {\n            sel.anchorNode = sel.focusNode = null;\n            sel.anchorOffset = sel.focusOffset = 0;\n            sel.rangeCount = 0;\n            sel.isCollapsed = true;\n            sel._ranges.length = 0;\n        }\n\n        function getNativeRange(range) {\n            var nativeRange;\n            if (range instanceof DomRange) {\n                nativeRange = api.createNativeRange(range.getDocument());\n                nativeRange.setEnd(range.endContainer, range.endOffset);\n                nativeRange.setStart(range.startContainer, range.startOffset);\n            } else if (range instanceof WrappedRange) {\n                nativeRange = range.nativeRange;\n            } else if (features.implementsDomRange && (range instanceof dom.getWindow(range.startContainer).Range)) {\n                nativeRange = range;\n            }\n            return nativeRange;\n        }\n\n        function rangeContainsSingleElement(rangeNodes) {\n            if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n                return false;\n            }\n            for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n                if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function getSingleElementFromRange(range) {\n            var nodes = range.getNodes();\n            if (!rangeContainsSingleElement(nodes)) {\n                throw module.createError("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");\n            }\n            return nodes[0];\n        }\n\n        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange\n        function isTextRange(range) {\n            return !!range && typeof range.text != "undefined";\n        }\n\n        function updateFromTextRange(sel, range) {\n            // Create a Range from the selected TextRange\n            var wrappedRange = new WrappedRange(range);\n            sel._ranges = [wrappedRange];\n\n            updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n            sel.rangeCount = 1;\n            sel.isCollapsed = wrappedRange.collapsed;\n        }\n\n        function updateControlSelection(sel) {\n            // Update the wrapped selection based on what\'s now in the native selection\n            sel._ranges.length = 0;\n            if (sel.docSelection.type == "None") {\n                updateEmptySelection(sel);\n            } else {\n                var controlRange = sel.docSelection.createRange();\n                if (isTextRange(controlRange)) {\n                    // This case (where the selection type is "Control" and calling createRange() on the selection returns\n                    // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n                    // ControlRange have been removed from the ControlRange and removed from the document.\n                    updateFromTextRange(sel, controlRange);\n                } else {\n                    sel.rangeCount = controlRange.length;\n                    var range, doc = getDocument(controlRange.item(0));\n                    for (var i = 0; i < sel.rangeCount; ++i) {\n                        range = api.createRange(doc);\n                        range.selectNode(controlRange.item(i));\n                        sel._ranges.push(range);\n                    }\n                    sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n                }\n            }\n        }\n\n        function addRangeToControlSelection(sel, range) {\n            var controlRange = sel.docSelection.createRange();\n            var rangeElement = getSingleElementFromRange(range);\n\n            // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n            // contained by the supplied range\n            var doc = getDocument(controlRange.item(0));\n            var newControlRange = getBody(doc).createControlRange();\n            for (var i = 0, len = controlRange.length; i < len; ++i) {\n                newControlRange.add(controlRange.item(i));\n            }\n            try {\n                newControlRange.add(rangeElement);\n            } catch (ex) {\n                throw module.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");\n            }\n            newControlRange.select();\n\n            // Update the wrapped selection based on what\'s now in the native selection\n            updateControlSelection(sel);\n        }\n\n        var getSelectionRangeAt;\n\n        if (isHostMethod(testSelection, "getRangeAt")) {\n            // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.\n            // Unfortunately, I didn\'t write a comment about the specifics and am now scared to take it out. Let that be a\n            // lesson to us all, especially me.\n            getSelectionRangeAt = function(sel, index) {\n                try {\n                    return sel.getRangeAt(index);\n                } catch (ex) {\n                    return null;\n                }\n            };\n        } else if (selectionHasAnchorAndFocus) {\n            getSelectionRangeAt = function(sel) {\n                var doc = getDocument(sel.anchorNode);\n                var range = api.createRange(doc);\n                range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);\n\n                // Handle the case when the selection was selected backwards (from the end to the start in the\n                // document)\n                if (range.collapsed !== this.isCollapsed) {\n                    range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);\n                }\n\n                return range;\n            };\n        }\n\n        function WrappedSelection(selection, docSelection, win) {\n            this.nativeSelection = selection;\n            this.docSelection = docSelection;\n            this._ranges = [];\n            this.win = win;\n            this.refresh();\n        }\n\n        WrappedSelection.prototype = api.selectionPrototype;\n\n        function deleteProperties(sel) {\n            sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;\n            sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;\n            sel.detached = true;\n        }\n\n        var cachedRangySelections = [];\n\n        function actOnCachedSelection(win, action) {\n            var i = cachedRangySelections.length, cached, sel;\n            while (i--) {\n                cached = cachedRangySelections[i];\n                sel = cached.selection;\n                if (action == "deleteAll") {\n                    deleteProperties(sel);\n                } else if (cached.win == win) {\n                    if (action == "delete") {\n                        cachedRangySelections.splice(i, 1);\n                        return true;\n                    } else {\n                        return sel;\n                    }\n                }\n            }\n            if (action == "deleteAll") {\n                cachedRangySelections.length = 0;\n            }\n            return null;\n        }\n\n        var getSelection = function(win) {\n            // Check if the parameter is a Rangy Selection object\n            if (win && win instanceof WrappedSelection) {\n                win.refresh();\n                return win;\n            }\n\n            win = getWindow(win, "getNativeSelection");\n\n            var sel = actOnCachedSelection(win);\n            var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;\n            if (sel) {\n                sel.nativeSelection = nativeSel;\n                sel.docSelection = docSel;\n                sel.refresh();\n            } else {\n                sel = new WrappedSelection(nativeSel, docSel, win);\n                cachedRangySelections.push( { win: win, selection: sel } );\n            }\n            return sel;\n        };\n\n        api.getSelection = getSelection;\n\n        util.createAliasForDeprecatedMethod(api, "getIframeSelection", "getSelection");\n\n        var selProto = WrappedSelection.prototype;\n\n        function createControlSelection(sel, ranges) {\n            // Ensure that the selection becomes of type "Control"\n            var doc = getDocument(ranges[0].startContainer);\n            var controlRange = getBody(doc).createControlRange();\n            for (var i = 0, el, len = ranges.length; i < len; ++i) {\n                el = getSingleElementFromRange(ranges[i]);\n                try {\n                    controlRange.add(el);\n                } catch (ex) {\n                    throw module.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");\n                }\n            }\n            controlRange.select();\n\n            // Update the wrapped selection based on what\'s now in the native selection\n            updateControlSelection(sel);\n        }\n\n        // Selecting a range\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {\n            selProto.removeAllRanges = function() {\n                this.nativeSelection.removeAllRanges();\n                updateEmptySelection(this);\n            };\n\n            var addRangeBackward = function(sel, range) {\n                addRangeBackwardToNative(sel.nativeSelection, range);\n                sel.refresh();\n            };\n\n            if (selectionHasRangeCount) {\n                selProto.addRange = function(range, direction) {\n                    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                        addRangeToControlSelection(this, range);\n                    } else {\n                        if (isDirectionBackward(direction) && selectionHasExtend) {\n                            addRangeBackward(this, range);\n                        } else {\n                            var previousRangeCount;\n                            if (selectionSupportsMultipleRanges) {\n                                previousRangeCount = this.rangeCount;\n                            } else {\n                                this.removeAllRanges();\n                                previousRangeCount = 0;\n                            }\n                            // Clone the native range so that changing the selected range does not affect the selection.\n                            // This is contrary to the spec but is the only way to achieve consistency between browsers. See\n                            // issue 80.\n                            var clonedNativeRange = getNativeRange(range).cloneRange();\n                            try {\n                                this.nativeSelection.addRange(clonedNativeRange);\n                            } catch (ex) {\n                            }\n\n                            // Check whether adding the range was successful\n                            this.rangeCount = this.nativeSelection.rangeCount;\n\n                            if (this.rangeCount == previousRangeCount + 1) {\n                                // The range was added successfully\n\n                                // Check whether the range that we added to the selection is reflected in the last range extracted from\n                                // the selection\n                                if (api.config.checkSelectionRanges) {\n                                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                                    if (nativeRange && !rangesEqual(nativeRange, range)) {\n                                        // Happens in WebKit with, for example, a selection placed at the start of a text node\n                                        range = new WrappedRange(nativeRange);\n                                    }\n                                }\n                                this._ranges[this.rangeCount - 1] = range;\n                                updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));\n                                this.isCollapsed = selectionIsCollapsed(this);\n                            } else {\n                                // The range was not added successfully. The simplest thing is to refresh\n                                this.refresh();\n                            }\n                        }\n                    }\n                };\n            } else {\n                selProto.addRange = function(range, direction) {\n                    if (isDirectionBackward(direction) && selectionHasExtend) {\n                        addRangeBackward(this, range);\n                    } else {\n                        this.nativeSelection.addRange(getNativeRange(range));\n                        this.refresh();\n                    }\n                };\n            }\n\n            selProto.setRanges = function(ranges) {\n                if (implementsControlRange && implementsDocSelection && ranges.length > 1) {\n                    createControlSelection(this, ranges);\n                } else {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        this.addRange(ranges[i]);\n                    }\n                }\n            };\n        } else if (isHostMethod(testSelection, "empty") && isHostMethod(testRange, "select") &&\n                   implementsControlRange && useDocumentSelection) {\n\n            selProto.removeAllRanges = function() {\n                // Added try/catch as fix for issue #21\n                try {\n                    this.docSelection.empty();\n\n                    // Check for empty() not working (issue #24)\n                    if (this.docSelection.type != "None") {\n                        // Work around failure to empty a control selection by instead selecting a TextRange and then\n                        // calling empty()\n                        var doc;\n                        if (this.anchorNode) {\n                            doc = getDocument(this.anchorNode);\n                        } else if (this.docSelection.type == CONTROL) {\n                            var controlRange = this.docSelection.createRange();\n                            if (controlRange.length) {\n                                doc = getDocument( controlRange.item(0) );\n                            }\n                        }\n                        if (doc) {\n                            var textRange = getBody(doc).createTextRange();\n                            textRange.select();\n                            this.docSelection.empty();\n                        }\n                    }\n                } catch(ex) {}\n                updateEmptySelection(this);\n            };\n\n            selProto.addRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    addRangeToControlSelection(this, range);\n                } else {\n                    api.WrappedTextRange.rangeToTextRange(range).select();\n                    this._ranges[0] = range;\n                    this.rangeCount = 1;\n                    this.isCollapsed = this._ranges[0].collapsed;\n                    updateAnchorAndFocusFromRange(this, range, false);\n                }\n            };\n\n            selProto.setRanges = function(ranges) {\n                this.removeAllRanges();\n                var rangeCount = ranges.length;\n                if (rangeCount > 1) {\n                    createControlSelection(this, ranges);\n                } else if (rangeCount) {\n                    this.addRange(ranges[0]);\n                }\n            };\n        } else {\n            module.fail("No means of selecting a Range or TextRange was found");\n            return false;\n        }\n\n        selProto.getRangeAt = function(index) {\n            if (index < 0 || index >= this.rangeCount) {\n                throw new DOMException("INDEX_SIZE_ERR");\n            } else {\n                // Clone the range to preserve selection-range independence. See issue 80.\n                return this._ranges[index].cloneRange();\n            }\n        };\n\n        var refreshSelection;\n\n        if (useDocumentSelection) {\n            refreshSelection = function(sel) {\n                var range;\n                if (api.isSelectionValid(sel.win)) {\n                    range = sel.docSelection.createRange();\n                } else {\n                    range = getBody(sel.win.document).createTextRange();\n                    range.collapse(true);\n                }\n\n                if (sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else if (isTextRange(range)) {\n                    updateFromTextRange(sel, range);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else if (isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {\n            refreshSelection = function(sel) {\n                if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n                    updateControlSelection(sel);\n                } else {\n                    sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n                    if (sel.rangeCount) {\n                        for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n                        }\n                        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));\n                        sel.isCollapsed = selectionIsCollapsed(sel);\n                    } else {\n                        updateEmptySelection(sel);\n                    }\n                }\n            };\n        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {\n            refreshSelection = function(sel) {\n                var range, nativeSel = sel.nativeSelection;\n                if (nativeSel.anchorNode) {\n                    range = getSelectionRangeAt(nativeSel, 0);\n                    sel._ranges = [range];\n                    sel.rangeCount = 1;\n                    updateAnchorAndFocusFromNativeSelection(sel);\n                    sel.isCollapsed = selectionIsCollapsed(sel);\n                } else {\n                    updateEmptySelection(sel);\n                }\n            };\n        } else {\n            module.fail("No means of obtaining a Range or TextRange from the user\'s selection was found");\n            return false;\n        }\n\n        selProto.refresh = function(checkForChanges) {\n            var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n            var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;\n\n            refreshSelection(this);\n            if (checkForChanges) {\n                // Check the range count first\n                var i = oldRanges.length;\n                if (i != this._ranges.length) {\n                    return true;\n                }\n\n                // Now check the direction. Checking the anchor position is the same is enough since we\'re checking all the\n                // ranges after this\n                if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {\n                    return true;\n                }\n\n                // Finally, compare each range in turn\n                while (i--) {\n                    if (!rangesEqual(oldRanges[i], this._ranges[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n\n        // Removal of a single range\n        var removeRangeManually = function(sel, range) {\n            var ranges = sel.getAllRanges();\n            sel.removeAllRanges();\n            for (var i = 0, len = ranges.length; i < len; ++i) {\n                if (!rangesEqual(range, ranges[i])) {\n                    sel.addRange(ranges[i]);\n                }\n            }\n            if (!sel.rangeCount) {\n                updateEmptySelection(sel);\n            }\n        };\n\n        if (implementsControlRange && implementsDocSelection) {\n            selProto.removeRange = function(range) {\n                if (this.docSelection.type == CONTROL) {\n                    var controlRange = this.docSelection.createRange();\n                    var rangeElement = getSingleElementFromRange(range);\n\n                    // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n                    // element contained by the supplied range\n                    var doc = getDocument(controlRange.item(0));\n                    var newControlRange = getBody(doc).createControlRange();\n                    var el, removed = false;\n                    for (var i = 0, len = controlRange.length; i < len; ++i) {\n                        el = controlRange.item(i);\n                        if (el !== rangeElement || removed) {\n                            newControlRange.add(controlRange.item(i));\n                        } else {\n                            removed = true;\n                        }\n                    }\n                    newControlRange.select();\n\n                    // Update the wrapped selection based on what\'s now in the native selection\n                    updateControlSelection(this);\n                } else {\n                    removeRangeManually(this, range);\n                }\n            };\n        } else {\n            selProto.removeRange = function(range) {\n                removeRangeManually(this, range);\n            };\n        }\n\n        // Detecting if a selection is backward\n        var selectionIsBackward;\n        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {\n            selectionIsBackward = winSelectionIsBackward;\n\n            selProto.isBackward = function() {\n                return selectionIsBackward(this);\n            };\n        } else {\n            selectionIsBackward = selProto.isBackward = function() {\n                return false;\n            };\n        }\n\n        // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"\n        selProto.isBackwards = selProto.isBackward;\n\n        // Selection stringifier\n        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla\'s implementation.\n        // The current spec does not yet define this method.\n        selProto.toString = function() {\n            var rangeTexts = [];\n            for (var i = 0, len = this.rangeCount; i < len; ++i) {\n                rangeTexts[i] = "" + this._ranges[i];\n            }\n            return rangeTexts.join("");\n        };\n\n        function assertNodeInSameDocument(sel, node) {\n            if (sel.win.document != getDocument(node)) {\n                throw new DOMException("WRONG_DOCUMENT_ERR");\n            }\n        }\n\n        // No current browser conforms fully to the spec for this method, so Rangy\'s own method is always used\n        selProto.collapse = function(node, offset) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.collapseToPoint(node, offset);\n            this.setSingleRange(range);\n            this.isCollapsed = true;\n        };\n\n        selProto.collapseToStart = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[0];\n                this.collapse(range.startContainer, range.startOffset);\n            } else {\n                throw new DOMException("INVALID_STATE_ERR");\n            }\n        };\n\n        selProto.collapseToEnd = function() {\n            if (this.rangeCount) {\n                var range = this._ranges[this.rangeCount - 1];\n                this.collapse(range.endContainer, range.endOffset);\n            } else {\n                throw new DOMException("INVALID_STATE_ERR");\n            }\n        };\n\n        // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as\n        // specified so the native implementation is never used by Rangy.\n        selProto.selectAllChildren = function(node) {\n            assertNodeInSameDocument(this, node);\n            var range = api.createRange(node);\n            range.selectNodeContents(node);\n            this.setSingleRange(range);\n        };\n\n        selProto.deleteFromDocument = function() {\n            // Sepcial behaviour required for IE\'s control selections\n            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n                var controlRange = this.docSelection.createRange();\n                var element;\n                while (controlRange.length) {\n                    element = controlRange.item(0);\n                    controlRange.remove(element);\n                    dom.removeNode(element);\n                }\n                this.refresh();\n            } else if (this.rangeCount) {\n                var ranges = this.getAllRanges();\n                if (ranges.length) {\n                    this.removeAllRanges();\n                    for (var i = 0, len = ranges.length; i < len; ++i) {\n                        ranges[i].deleteContents();\n                    }\n                    // The spec says nothing about what the selection should contain after calling deleteContents on each\n                    // range. Firefox moves the selection to where the final selected range was, so we emulate that\n                    this.addRange(ranges[len - 1]);\n                }\n            }\n        };\n\n        // The following are non-standard extensions\n        selProto.eachRange = function(func, returnValue) {\n            for (var i = 0, len = this._ranges.length; i < len; ++i) {\n                if ( func( this.getRangeAt(i) ) ) {\n                    return returnValue;\n                }\n            }\n        };\n\n        selProto.getAllRanges = function() {\n            var ranges = [];\n            this.eachRange(function(range) {\n                ranges.push(range);\n            });\n            return ranges;\n        };\n\n        selProto.setSingleRange = function(range, direction) {\n            this.removeAllRanges();\n            this.addRange(range, direction);\n        };\n\n        selProto.callMethodOnEachRange = function(methodName, params) {\n            var results = [];\n            this.eachRange( function(range) {\n                results.push( range[methodName].apply(range, params || []) );\n            } );\n            return results;\n        };\n\n        function createStartOrEndSetter(isStart) {\n            return function(node, offset) {\n                var range;\n                if (this.rangeCount) {\n                    range = this.getRangeAt(0);\n                    range["set" + (isStart ? "Start" : "End")](node, offset);\n                } else {\n                    range = api.createRange(this.win.document);\n                    range.setStartAndEnd(node, offset);\n                }\n                this.setSingleRange(range, this.isBackward());\n            };\n        }\n\n        selProto.setStart = createStartOrEndSetter(true);\n        selProto.setEnd = createStartOrEndSetter(false);\n\n        // Add select() method to Range prototype. Any existing selection will be removed.\n        api.rangePrototype.select = function(direction) {\n            getSelection( this.getDocument() ).setSingleRange(this, direction);\n        };\n\n        selProto.changeEachRange = function(func) {\n            var ranges = [];\n            var backward = this.isBackward();\n\n            this.eachRange(function(range) {\n                func(range);\n                ranges.push(range);\n            });\n\n            this.removeAllRanges();\n            if (backward && ranges.length == 1) {\n                this.addRange(ranges[0], "backward");\n            } else {\n                this.setRanges(ranges);\n            }\n        };\n\n        selProto.containsNode = function(node, allowPartial) {\n            return this.eachRange( function(range) {\n                return range.containsNode(node, allowPartial);\n            }, true ) || false;\n        };\n\n        selProto.getBookmark = function(containerNode) {\n            return {\n                backward: this.isBackward(),\n                rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])\n            };\n        };\n\n        selProto.moveToBookmark = function(bookmark) {\n            var selRanges = [];\n            for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++]; ) {\n                range = api.createRange(this.win);\n                range.moveToBookmark(rangeBookmark);\n                selRanges.push(range);\n            }\n            if (bookmark.backward) {\n                this.setSingleRange(selRanges[0], "backward");\n            } else {\n                this.setRanges(selRanges);\n            }\n        };\n\n        selProto.saveRanges = function() {\n            return {\n                backward: this.isBackward(),\n                ranges: this.callMethodOnEachRange("cloneRange")\n            };\n        };\n\n        selProto.restoreRanges = function(selRanges) {\n            this.removeAllRanges();\n            for (var i = 0, range; range = selRanges.ranges[i]; ++i) {\n                this.addRange(range, (selRanges.backward && i == 0));\n            }\n        };\n\n        selProto.toHtml = function() {\n            var rangeHtmls = [];\n            this.eachRange(function(range) {\n                rangeHtmls.push( DomRange.toHtml(range) );\n            });\n            return rangeHtmls.join("");\n        };\n\n        if (features.implementsTextRange) {\n            selProto.getNativeTextRange = function() {\n                var sel, textRange;\n                if ( (sel = this.docSelection) ) {\n                    var range = sel.createRange();\n                    if (isTextRange(range)) {\n                        return range;\n                    } else {\n                        throw module.createError("getNativeTextRange: selection is a control selection");\n                    }\n                } else if (this.rangeCount > 0) {\n                    return api.WrappedTextRange.rangeToTextRange( this.getRangeAt(0) );\n                } else {\n                    throw module.createError("getNativeTextRange: selection contains no range");\n                }\n            };\n        }\n\n        function inspect(sel) {\n            var rangeInspects = [];\n            var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n            var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n            var name = (typeof sel.getName == "function") ? sel.getName() : "Selection";\n\n            if (typeof sel.rangeCount != "undefined") {\n                for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                    rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n                }\n            }\n            return "[" + name + "(Ranges: " + rangeInspects.join(", ") +\n                    ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";\n        }\n\n        selProto.getName = function() {\n            return "WrappedSelection";\n        };\n\n        selProto.inspect = function() {\n            return inspect(this);\n        };\n\n        selProto.detach = function() {\n            actOnCachedSelection(this.win, "delete");\n            deleteProperties(this);\n        };\n\n        WrappedSelection.detachAll = function() {\n            actOnCachedSelection(null, "deleteAll");\n        };\n\n        WrappedSelection.inspect = inspect;\n        WrappedSelection.isDirectionBackward = isDirectionBackward;\n\n        api.Selection = WrappedSelection;\n\n        api.selectionPrototype = selProto;\n\n        api.addShimListener(function(win) {\n            if (typeof win.getSelection == "undefined") {\n                win.getSelection = function() {\n                    return getSelection(win);\n                };\n            }\n            win = null;\n        });\n    });\n    \n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Wait for document to load before initializing\n    var docReady = false;\n\n    var loadHandler = function(e) {\n        if (!docReady) {\n            docReady = true;\n            if (!api.initialized && api.config.autoInitialize) {\n                init();\n            }\n        }\n    };\n\n    if (isBrowser) {\n        // Test whether the document has already been loaded and initialize immediately if so\n        if (document.readyState == "complete") {\n            loadHandler();\n        } else {\n            if (isHostMethod(document, "addEventListener")) {\n                document.addEventListener("DOMContentLoaded", loadHandler, false);\n            }\n\n            // Add a fallback in case the DOMContentLoaded event isn\'t supported\n            addListener(window, "load", loadHandler);\n        }\n    }\n\n    return api;\n})()\n\n\n\n//# sourceURL=webpack://appjs/./src/lib/rangy-core.js?')},"./src/lib/rangy-highlighter.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rangy_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rangy-core */ "./src/lib/rangy-core.js");\n/**\n * Highlighter module for Rangy, a cross-browser JavaScript range and selection library\n * https://github.com/timdown/rangy\n *\n * Depends on Rangy core, ClassApplier and optionally TextRange modules.\n *\n * Copyright 2015, Tim Down\n * Licensed under the MIT license.\n * Version: 1.3.1-dev\n * Build date: 20 May 2015\n */\n\n\n\n(function(rangy) {\n    rangy.createModule("Highlighter", ["ClassApplier"], function(api, module) {\n        var dom = api.dom;\n        var contains = dom.arrayContains;\n        var getBody = dom.getBody;\n        var createOptions = api.util.createOptions;\n        var forEach = api.util.forEach;\n        var nextHighlightId = 1;\n\n        // Puts highlights in order, last in document first.\n        function compareHighlights(h1, h2) {\n            return h1.characterRange.start - h2.characterRange.start;\n        }\n\n        function getContainerElement(doc, id) {\n            return id ? doc.getElementById(id) : getBody(doc);\n        }\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var highlighterTypes = {};\n\n        function HighlighterType(type, converterCreator) {\n            this.type = type;\n            this.converterCreator = converterCreator;\n        }\n\n        HighlighterType.prototype.create = function() {\n            var converter = this.converterCreator();\n            converter.type = this.type;\n            return converter;\n        };\n\n        function registerHighlighterType(type, converterCreator) {\n            highlighterTypes[type] = new HighlighterType(type, converterCreator);\n        }\n\n        function getConverter(type) {\n            var highlighterType = highlighterTypes[type];\n            if (highlighterType instanceof HighlighterType) {\n                return highlighterType.create();\n            } else {\n                throw new Error("Highlighter type \'" + type + "\' is not valid");\n            }\n        }\n\n        api.registerHighlighterType = registerHighlighterType;\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        function CharacterRange(start, end) {\n            this.start = start;\n            this.end = end;\n        }\n\n        CharacterRange.prototype = {\n            intersects: function(charRange) {\n                return this.start < charRange.end && this.end > charRange.start;\n            },\n\n            isContiguousWith: function(charRange) {\n                return this.start == charRange.end || this.end == charRange.start;\n            },\n\n            union: function(charRange) {\n                return new CharacterRange(Math.min(this.start, charRange.start), Math.max(this.end, charRange.end));\n            },\n\n            intersection: function(charRange) {\n                return new CharacterRange(Math.max(this.start, charRange.start), Math.min(this.end, charRange.end));\n            },\n\n            getComplements: function(charRange) {\n                var ranges = [];\n                if (this.start >= charRange.start) {\n                    if (this.end <= charRange.end) {\n                        return [];\n                    }\n                    ranges.push(new CharacterRange(charRange.end, this.end));\n                } else {\n                    ranges.push(new CharacterRange(this.start, Math.min(this.end, charRange.start)));\n                    if (this.end > charRange.end) {\n                        ranges.push(new CharacterRange(charRange.end, this.end));\n                    }\n                }\n                return ranges;\n            },\n\n            toString: function() {\n                return "[CharacterRange(" + this.start + ", " + this.end + ")]";\n            }\n        };\n\n        CharacterRange.fromCharacterRange = function(charRange) {\n            return new CharacterRange(charRange.start, charRange.end);\n        };\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        var textContentConverter = {\n            rangeToCharacterRange: function(range, containerNode) {\n                var bookmark = range.getBookmark(containerNode);\n                return new CharacterRange(bookmark.start, bookmark.end);\n            },\n\n            characterRangeToRange: function(doc, characterRange, containerNode) {\n                var range = api.createRange(doc);\n                range.moveToBookmark({\n                    start: characterRange.start,\n                    end: characterRange.end,\n                    containerNode: containerNode\n                });\n\n                return range;\n            },\n\n            serializeSelection: function(selection, containerNode) {\n                var ranges = selection.getAllRanges(), rangeCount = ranges.length;\n                var rangeInfos = [];\n\n                var backward = rangeCount == 1 && selection.isBackward();\n\n                for (var i = 0, len = ranges.length; i < len; ++i) {\n                    rangeInfos[i] = {\n                        characterRange: this.rangeToCharacterRange(ranges[i], containerNode),\n                        backward: backward\n                    };\n                }\n\n                return rangeInfos;\n            },\n\n            restoreSelection: function(selection, savedSelection, containerNode) {\n                selection.removeAllRanges();\n                var doc = selection.win.document;\n                for (var i = 0, len = savedSelection.length, range, rangeInfo, characterRange; i < len; ++i) {\n                    rangeInfo = savedSelection[i];\n                    characterRange = rangeInfo.characterRange;\n                    range = this.characterRangeToRange(doc, rangeInfo.characterRange, containerNode);\n                    selection.addRange(range, rangeInfo.backward);\n                }\n            }\n        };\n\n        registerHighlighterType("textContent", function() {\n            return textContentConverter;\n        });\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        // Lazily load the TextRange-based converter so that the dependency is only checked when required.\n        registerHighlighterType("TextRange", (function() {\n            var converter;\n\n            return function() {\n                if (!converter) {\n                    // Test that textRangeModule exists and is supported\n                    var textRangeModule = api.modules.TextRange;\n                    if (!textRangeModule) {\n                        throw new Error("TextRange module is missing.");\n                    } else if (!textRangeModule.supported) {\n                        throw new Error("TextRange module is present but not supported.");\n                    }\n\n                    converter = {\n                        rangeToCharacterRange: function(range, containerNode) {\n                            return CharacterRange.fromCharacterRange( range.toCharacterRange(containerNode) );\n                        },\n\n                        characterRangeToRange: function(doc, characterRange, containerNode) {\n                            var range = api.createRange(doc);\n                            range.selectCharacters(containerNode, characterRange.start, characterRange.end);\n                            return range;\n                        },\n\n                        serializeSelection: function(selection, containerNode) {\n                            return selection.saveCharacterRanges(containerNode);\n                        },\n\n                        restoreSelection: function(selection, savedSelection, containerNode) {\n                            selection.restoreCharacterRanges(containerNode, savedSelection);\n                        }\n                    };\n                }\n\n                return converter;\n            };\n        })());\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        function Highlight(doc, characterRange, classApplier, converter, id, containerElementId) {\n            if (id) {\n                this.id = id;\n                nextHighlightId = Math.max(nextHighlightId, id + 1);\n            } else {\n                this.id = nextHighlightId++;\n            }\n            this.characterRange = characterRange;\n            this.doc = doc;\n            this.classApplier = classApplier;\n            this.converter = converter;\n            this.containerElementId = containerElementId || null;\n            this.applied = false;\n        }\n\n        Highlight.prototype = {\n            getContainerElement: function() {\n                return getContainerElement(this.doc, this.containerElementId);\n            },\n\n            getRange: function() {\n                return this.converter.characterRangeToRange(this.doc, this.characterRange, this.getContainerElement());\n            },\n\n            fromRange: function(range) {\n                this.characterRange = this.converter.rangeToCharacterRange(range, this.getContainerElement());\n            },\n\n            getText: function() {\n                return this.getRange().toString();\n            },\n\n            containsElement: function(el) {\n                return this.getRange().containsNodeContents(el.firstChild);\n            },\n\n            unapply: function() {\n                /*\n                    侵入性 太大了 , 但是没有办法 ,暂时只能这样 \n                    并且这个移除要 优先于 classApplier , 这样才可以保证 classApplier 把创建的 span 移除掉 \n                */\n                this.hasNote = false \n                this.classApplier.undoToRange(this.getRange());\n                this.applied = false;\n            },\n\n            apply: function() {\n                this.classApplier.applyToRange(this.getRange());\n                this.applied = true;\n            },\n\n            changeClassApplier : function(newClassApplier){\n                var elms = this.getHighlightElements() // 必须先获取 这个 ,因为  getHighlightElements 依赖于  this.classApplier\n                var oldClassName = this.classApplier.className \n                var newClassName = newClassApplier.className\n                this.classApplier = newClassApplier\n                if (this.applied){ \n                    // 更换 class  \n                    if(!!elms){\n                         elms.forEach((x)=> x.classList.replace(oldClassName ,newClassName ))\n                    } \n                }\n            },\n\n            getHighlightElements: function() {\n                return this.classApplier.getElementsWithClassIntersectingRange(this.getRange());\n            },\n\n            toString: function() {\n                return "[Highlight(ID: " + this.id + ", class: " + this.classApplier.className + ", character range: " +\n                    this.characterRange.start + " - " + this.characterRange.end + ")]";\n            },\n            /**\n             * @param {boolean} val\n             */\n            set hasNote(val){\n                this.XhasNote = val\n                if (val){\n                    this.addCustomClass()\n                }else{\n                    this.removeCustomClass()\n                }\n            },\n            get hasNote(){\n                return this.XhasNote || false\n            },\n\n            addCustomClass : function(){\n                // 会存在 多个 HighlightElements 的情况 ,比如: 如果 跨越 多个 div 块元素 , 那么 就会存在多个  HighlightElement\n               var elms = this.getHighlightElements() \n               if(!!elms){\n                    // elms[0].classList.add(\'marker-note\');\n                    elms.forEach((x)=> x.classList.add(\'marker-note\'))\n               }\n            },\n\n            removeCustomClass : function(){\n               var elms = this.getHighlightElements() \n               if(!!elms){\n                    elms.forEach((x)=> x.classList.remove(\'marker-note\'))\n               }\n            },\n\n        };\n\n        /*----------------------------------------------------------------------------------------------------------------*/\n\n        function Highlighter(doc, type) {\n            type = type || "textContent";\n            this.doc = doc || document;\n            this.classAppliers = {};\n            this.highlights = [];\n            this.converter = getConverter(type);\n        }\n\n        Highlighter.prototype = {\n            addClassApplier: function(classApplier) {\n                this.classAppliers[classApplier.className] = classApplier;\n            },\n\n            getHighlightForElement: function(el) {\n                var highlights = this.highlights;\n                for (var i = 0, len = highlights.length; i < len; ++i) {\n                    if (highlights[i].containsElement(el)) {\n                        return highlights[i];\n                    }\n                }\n                return null;\n            },\n\n            removeHighlights: function(highlights) {\n                for (var i = 0, len = this.highlights.length, highlight; i < len; ++i) {\n                    highlight = this.highlights[i];\n                    if (contains(highlights, highlight)) {\n                        highlight.unapply();\n                        this.highlights.splice(i--, 1);\n                    }\n                }\n            },\n\n            removeAllHighlights: function() {\n                this.removeHighlights(this.highlights);\n            },\n\n            getIntersectingHighlights: function(ranges) {\n                // Test each range against each of the highlighted ranges to see whether they overlap\n                var intersectingHighlights = [], highlights = this.highlights;\n                forEach(ranges, function(range) {\n                    //var selCharRange = converter.rangeToCharacterRange(range);\n                    forEach(highlights, function(highlight) {\n                        if (range.intersectsRange( highlight.getRange() ) && !contains(intersectingHighlights, highlight)) {\n                            intersectingHighlights.push(highlight);\n                        }\n                    });\n                });\n\n                return intersectingHighlights;\n            },\n\n            highlightCharacterRanges: function(className, charRanges, options) {\n                var i, len, j;\n                var highlights = this.highlights;\n                var converter = this.converter;\n                var doc = this.doc;\n                var highlightsToRemove = [];\n                var classApplier = className ? this.classAppliers[className] : null;\n\n                options = createOptions(options, {\n                    containerElementId: null,\n                    exclusive: true\n                });\n\n                var containerElementId = options.containerElementId;\n                var exclusive = options.exclusive;\n\n                var containerElement, containerElementRange, containerElementCharRange;\n                if (containerElementId) {\n                    containerElement = this.doc.getElementById(containerElementId);\n                    if (containerElement) {\n                        containerElementRange = api.createRange(this.doc);\n                        containerElementRange.selectNodeContents(containerElement);\n                        containerElementCharRange = new CharacterRange(0, containerElementRange.toString().length);\n                    }\n                }\n\n                var charRange, highlightCharRange, removeHighlight, isSameClassApplier, highlightsToKeep, splitHighlight;\n\n                for (i = 0, len = charRanges.length; i < len; ++i) {\n                    charRange = charRanges[i];\n                    highlightsToKeep = [];\n\n                    // Restrict character range to container element, if it exists\n                    if (containerElementCharRange) {\n                        charRange = charRange.intersection(containerElementCharRange);\n                    }\n\n                    // Ignore empty ranges\n                    if (charRange.start == charRange.end) {\n                        continue;\n                    }\n\n                    // Check for intersection with existing highlights. For each intersection, create a new highlight\n                    // which is the union of the highlight range and the selected range\n                    for (j = 0; j < highlights.length; ++j) {\n                        removeHighlight = false;\n\n                        if (containerElementId == highlights[j].containerElementId) {\n                            highlightCharRange = highlights[j].characterRange;\n                            isSameClassApplier = (classApplier == highlights[j].classApplier);\n                            splitHighlight = !isSameClassApplier && exclusive;\n\n                            // Replace the existing highlight if it needs to be:\n                            //  1. merged (isSameClassApplier)\n                            //  2. partially or entirely erased (className === null)\n                            //  3. partially or entirely replaced (isSameClassApplier == false && exclusive == true)\n                            if (    (highlightCharRange.intersects(charRange) || highlightCharRange.isContiguousWith(charRange)) &&\n                                    (isSameClassApplier || splitHighlight) ) {\n\n                                // Remove existing highlights, keeping the unselected parts\n                                if (splitHighlight) {\n                                    forEach(highlightCharRange.getComplements(charRange), function(rangeToAdd) {\n                                        highlightsToKeep.push( new Highlight(doc, rangeToAdd, highlights[j].classApplier, converter, null, containerElementId) );\n                                    });\n                                }\n\n                                removeHighlight = true;\n                                if (isSameClassApplier) {\n                                    charRange = highlightCharRange.union(charRange);\n                                }\n                            }\n                        }\n\n                        if (removeHighlight) {\n                            highlightsToRemove.push(highlights[j]);\n                            highlights[j] = new Highlight(doc, highlightCharRange.union(charRange), classApplier, converter, null, containerElementId);\n                        } else {\n                            highlightsToKeep.push(highlights[j]);\n                        }\n                    }\n\n                    // Add new range\n                    if (classApplier) {\n                        highlightsToKeep.push(new Highlight(doc, charRange, classApplier, converter, null, containerElementId));\n                    }\n                    this.highlights = highlights = highlightsToKeep;\n                }\n\n                // Remove the old highlights\n                forEach(highlightsToRemove, function(highlightToRemove) {\n                    highlightToRemove.unapply();\n                });\n\n                //add by callback for highlightsToRemove\n                if (options.onHighlightsRemove){\n                    options.onHighlightsRemove(highlightsToRemove)\n                }\n\n                // Apply new highlights\n                var newHighlights = [];\n                forEach(highlights, function(highlight) {\n                    if (!highlight.applied) {\n                        highlight.apply();\n                        newHighlights.push(highlight);\n                    }\n                });\n\n                return newHighlights;\n            },\n\n            highlightRanges: function(className, ranges, options) {\n                var selCharRanges = [];\n                var converter = this.converter;\n\n                options = createOptions(options, {\n                    containerElement: null,\n                    exclusive: true\n                });\n\n                var containerElement = options.containerElement;\n                var containerElementId = containerElement ? containerElement.id : null;\n                var containerElementRange;\n                if (containerElement) {\n                    containerElementRange = api.createRange(containerElement);\n                    containerElementRange.selectNodeContents(containerElement);\n                }\n\n                forEach(ranges, function(range) {\n                    var scopedRange = containerElement ? containerElementRange.intersection(range) : range;\n                    selCharRanges.push( converter.rangeToCharacterRange(scopedRange, containerElement || getBody(range.getDocument())) );\n                });\n\n                return this.highlightCharacterRanges(className, selCharRanges, {\n                    containerElementId: containerElementId,\n                    exclusive: options.exclusive,\n                    onHighlightsRemove:  options.onHighlightsRemove\n                });\n            },\n\n            highlightSelection: function(className, options) {\n                var converter = this.converter;\n                var classApplier = className ? this.classAppliers[className] : false;\n\n                options = createOptions(options, {\n                    containerElementId: null,\n                    exclusive: true\n                });\n\n                var containerElementId = options.containerElementId;\n                var exclusive = options.exclusive;\n                var selection = options.selection || api.getSelection(this.doc);\n                var doc = selection.win.document;\n                var containerElement = getContainerElement(doc, containerElementId);\n\n                if (!classApplier && className !== false) {\n                    throw new Error("No class applier found for class \'" + className + "\'");\n                }\n\n                // Store the existing selection as character ranges\n                var serializedSelection = converter.serializeSelection(selection, containerElement);\n\n                // Create an array of selected character ranges\n                var selCharRanges = [];\n                forEach(serializedSelection, function(rangeInfo) {\n                    selCharRanges.push( CharacterRange.fromCharacterRange(rangeInfo.characterRange) );\n                });\n\n                var newHighlights = this.highlightCharacterRanges(className, selCharRanges, {\n                    containerElementId: containerElementId,\n                    exclusive: exclusive,\n                    onHighlightsRemove:  options.onHighlightsRemove\n                });\n\n                // Restore selection\n                converter.restoreSelection(selection, serializedSelection, containerElement);\n\n                return newHighlights;\n            },\n\n            unhighlightSelection: function(selection) {\n                selection = selection || api.getSelection(this.doc);\n                var intersectingHighlights = this.getIntersectingHighlights( selection.getAllRanges() );\n                this.removeHighlights(intersectingHighlights);\n                selection.removeAllRanges();\n                return intersectingHighlights;\n            },\n\n            getHighlightsInSelection: function(selection) {\n                selection = selection || api.getSelection(this.doc);\n                return this.getIntersectingHighlights(selection.getAllRanges());\n            },\n\n            selectionOverlapsHighlight: function(selection) {\n                return this.getHighlightsInSelection(selection).length > 0;\n            },\n\n            serialize: function(options) {\n                var highlighter = this;\n                var highlights = highlighter.highlights;\n                var serializedType, serializedHighlights, convertType, serializationConverter;\n\n                highlights.sort(compareHighlights);\n                options = createOptions(options, {\n                    serializeHighlightText: false,\n                    type: highlighter.converter.type\n                });\n\n                serializedType = options.type;\n                convertType = (serializedType != highlighter.converter.type);\n\n                if (convertType) {\n                    serializationConverter = getConverter(serializedType);\n                }\n\n                serializedHighlights = ["type:" + serializedType];\n\n                forEach(highlights, function(highlight) {\n                    var characterRange = highlight.characterRange;\n                    var containerElement;\n\n                    // Convert to the current Highlighter\'s type, if different from the serialization type\n                    if (convertType) {\n                        containerElement = highlight.getContainerElement();\n                        characterRange = serializationConverter.rangeToCharacterRange(\n                            highlighter.converter.characterRangeToRange(highlighter.doc, characterRange, containerElement),\n                            containerElement\n                        );\n                    }\n\n                    var parts = [\n                        characterRange.start,\n                        characterRange.end,\n                        highlight.id,\n                        highlight.classApplier.className,\n                        highlight.containerElementId\n                    ];\n\n                    if (options.serializeHighlightText) {\n                        parts.push(highlight.getText());\n                    }\n                    serializedHighlights.push( parts.join("$") );\n                });\n\n                return serializedHighlights.join("|");\n            },\n\n            deserialize: function(serialized) {\n                var serializedHighlights = serialized.split("|");\n                var highlights = [];\n\n                var firstHighlight = serializedHighlights[0];\n                var regexResult;\n                var serializationType, serializationConverter, convertType = false;\n                if ( firstHighlight && (regexResult = /^type:(\\w+)$/.exec(firstHighlight)) ) {\n                    serializationType = regexResult[1];\n                    if (serializationType != this.converter.type) {\n                        serializationConverter = getConverter(serializationType);\n                        convertType = true;\n                    }\n                    serializedHighlights.shift();\n                } else {\n                    throw new Error("Serialized highlights are invalid.");\n                }\n\n                var classApplier, highlight, characterRange, containerElementId, containerElement;\n\n                for (var i = serializedHighlights.length, parts; i-- > 0; ) {\n                    parts = serializedHighlights[i].split("$");\n                    characterRange = new CharacterRange(+parts[0], +parts[1]);\n                    containerElementId = parts[4] || null;\n\n                    // Convert to the current Highlighter\'s type, if different from the serialization type\n                    if (convertType) {\n                        containerElement = getContainerElement(this.doc, containerElementId);\n                        characterRange = this.converter.rangeToCharacterRange(\n                            serializationConverter.characterRangeToRange(this.doc, characterRange, containerElement),\n                            containerElement\n                        );\n                    }\n\n                    classApplier = this.classAppliers[ parts[3] ];\n\n                    if (!classApplier) {\n                        throw new Error("No class applier found for class \'" + parts[3] + "\'");\n                    }\n\n                    highlight = new Highlight(this.doc, characterRange, classApplier, this.converter, parseInt(parts[2]), containerElementId);\n                    highlight.apply();\n                    highlights.push(highlight);\n                }\n                this.highlights = highlights;\n            }\n        };\n\n        api.Highlighter = Highlighter;\n\n        api.createHighlighter = function(doc, rangeCharacterOffsetConverterType) {\n            return new Highlighter(doc, rangeCharacterOffsetConverterType);\n        };\n    });\n    \n    return rangy;\n})(_rangy_core__WEBPACK_IMPORTED_MODULE_0__.rangy);\n\n\n//# sourceURL=webpack://appjs/./src/lib/rangy-highlighter.js?')},"./src/work.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('__webpack_require__(/*! ./allApplication.js */ "./src/allApplication.js")\n\n\n//# sourceURL=webpack://appjs/./src/work.js?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/app.js")})();